<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>RF Line of Sight Calculator</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css"/>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Barlow:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
  :root {
    --bg: #0d1117;
    --surface: #161b22;
    --border: #21262d;
    --accent-a: #3DFFA0;
    --accent-b: #69ff47;
    --accent-warn: #ff6b35;
    --text: #e6edf3;
    --muted: #7d8590;
    --grid: rgba(255,255,255,0.03);
    --panel-w: 520px;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }

  html, body {
    height: 100%;
    font-family: 'Barlow', sans-serif;
    background: var(--bg);
    color: var(--text);
    overflow: hidden;
  }

  body::before {
    content: '';
    position: fixed; inset: 0;
    background-image:
      linear-gradient(var(--grid) 1px, transparent 1px),
      linear-gradient(90deg, var(--grid) 1px, transparent 1px);
    background-size: 40px 40px;
    pointer-events: none; z-index: 0;
  }

  /* ‚îÄ‚îÄ HEADER ‚îÄ‚îÄ */
  .header {
    position: relative; z-index: 20;
    padding: 16px 28px;
    border-bottom: 1px solid var(--border);
    background: rgba(13,17,23,0.97);
    backdrop-filter: blur(10px);
    display: flex; align-items: center; gap: 20px;
    flex-shrink: 0;
  }
  .header-icon {
    width: 48px; height: 48px;
    background: rgba(61,255,160,0.06);
    border: 1px solid rgba(61,255,160,0.25);
    border-radius: 10px;
    display: flex; align-items: center; justify-content: center;
    flex-shrink: 0;
  }
  .header h1 { font-size: 20px; font-weight: 700; letter-spacing: 0.04em; text-transform: uppercase; }
  .header p  { font-size: 14px; color: var(--muted); font-family: 'Share Tech Mono', monospace; }
  .status-badge { margin-left: auto; }
  .badge {
    padding: 5px 14px; border-radius: 5px; border: 1px solid;
    font-family: 'Share Tech Mono', monospace; font-size: 14px;
    font-weight: 600; letter-spacing: 0.06em; text-transform: uppercase;
  }
  .badge-excellent { border-color:#3DFFA0; color:#3DFFA0; background:rgba(61,255,160,0.08); }
  .badge-good      { border-color:#69ff47; color:#69ff47; background:rgba(105,255,71,0.08); }
  .badge-fair      { border-color:#ffe066; color:#ffe066; background:rgba(255,224,102,0.08); }
  .badge-poor      { border-color:#ff9f43; color:#ff9f43; background:rgba(255,159,67,0.08); }
  .badge-unlikely  { border-color:#ff6b35; color:#ff6b35; background:rgba(255,107,53,0.08); }
  .badge-idle      { border-color:var(--muted); color:var(--muted); background:transparent; }

  /* ‚îÄ‚îÄ MAIN LAYOUT ‚îÄ‚îÄ */
  .app-shell {
    display: flex;
    flex-direction: column;
    height: 100vh;
    position: relative;
    z-index: 1;
  }

  .main {
    flex: 1;
    display: grid;
    grid-template-columns: var(--panel-w) 1fr;
    grid-template-rows: 1fr 260px;
    min-height: 0;
    overflow: hidden;
  }

  /* ‚îÄ‚îÄ PANEL ‚îÄ‚îÄ */
  .panel {
    grid-column: 1;
    grid-row: 1 / 3;
    background: var(--surface);
    border-right: 1px solid var(--border);
    overflow-y: auto;
    overflow-x: hidden;
    display: flex; flex-direction: column;
    position: relative;
    z-index: 10;
    min-width: 0;
  }
  .panel::-webkit-scrollbar { width: 6px; }
  .panel::-webkit-scrollbar-thumb { background: var(--border); border-radius: 4px; }

  .section { padding: 18px 20px; border-bottom: 1px solid var(--border); }

  .section-title {
    font-size: 16px; font-weight: 700; letter-spacing: 0.12em;
    text-transform: uppercase; color: var(--muted);
    margin-bottom: 14px; display: flex; align-items: center; gap: 10px;
  }
  .section-title::after { content:''; flex:1; height:1px; background:var(--border); }

  /* ‚îÄ‚îÄ SITE BLOCK ‚îÄ‚îÄ */
  .site-block {
    background: rgba(255,255,255,0.02);
    border: 1px solid var(--border);
    border-radius: 10px; padding: 15px; margin-bottom: 12px;
  }
  .site-block:last-child { margin-bottom: 0; }
  .site-header { display:flex; align-items:center; gap:10px; margin-bottom:13px; }
  .site-dot { width:14px; height:14px; border-radius:50%; flex-shrink:0; }
  .site-dot-a { background:#3DFFA0; box-shadow:0 0 8px #3DFFA0; }
  .site-dot-b { background:var(--accent-b); box-shadow:0 0 8px var(--accent-b); }
  .site-label { font-size:16px; font-weight:700; letter-spacing:0.06em; text-transform:uppercase; }
  .label-a { color:#3DFFA0; }
  .label-b { color:var(--accent-b); }

  /* Action buttons */
  .action-row { display:flex; gap:8px; margin-bottom:12px; }
  .icon-btn {
    flex:1; padding:9px 8px;
    background: rgba(255,255,255,0.03);
    border: 1px solid var(--border); border-radius:6px;
    color:var(--muted); font-size:14px; font-weight:600;
    font-family:'Barlow',sans-serif; letter-spacing:0.03em;
    cursor:pointer; transition:all 0.16s;
    display:flex; align-items:center; justify-content:center; gap:6px;
    white-space:nowrap; min-width:0;
  }
  .icon-btn:hover { color:var(--text); border-color:var(--muted); background:rgba(255,255,255,0.06); }
  .icon-btn.active-a { color:#3DFFA0; border-color:#3DFFA0; background:rgba(61,255,160,0.08); box-shadow:0 0 6px rgba(61,255,160,0.15); }
  .icon-btn.active-b { color:var(--accent-b); border-color:var(--accent-b); background:rgba(105,255,71,0.08); box-shadow:0 0 6px rgba(105,255,71,0.15); }
  .icon-btn:disabled { opacity:0.35; cursor:not-allowed; }

  /* Address */
  .address-row { position:relative; margin-bottom:7px; }
  .address-row input[type="text"] {
    width:100%; background:var(--bg); border:1px solid var(--border);
    border-radius:5px; color:var(--text);
    font-family:'Share Tech Mono',monospace; font-size:14px;
    padding:9px 40px 9px 12px; outline:none; transition:border-color 0.2s;
  }
  .address-row input[type="text"]::placeholder { color:var(--muted); opacity:0.55; }
  .address-row input[type="text"]:focus { border-color:#3DFFA0; }
  .addr-btn {
    position:absolute; right:8px; top:50%; transform:translateY(-50%);
    background:none; border:none; color:var(--muted);
    cursor:pointer; font-size:16px; padding:3px 4px; transition:color 0.15s;
    line-height:1;
  }
  .addr-btn:hover { color:var(--text); }
  .addr-status {
    font-size:14px; font-family:'Share Tech Mono',monospace;
    color:var(--muted); min-height:18px; margin-bottom:11px;
    line-height:1.4; word-break:break-word;
  }
  .addr-status.ok  { color:var(--accent-b); }
  .addr-status.err { color:var(--accent-warn); }
  .addr-status.inf { color:var(--muted); }

  /* Coords */
  .coord-row { display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-bottom:12px; }
  .field-group label {
    display:block; font-size:15px; color:var(--muted);
    font-family:'Share Tech Mono',monospace; letter-spacing:0.07em;
    text-transform:uppercase; margin-bottom:5px;
  }
  .field-group input[type="number"] {
    width:100%; background:var(--bg); border:1px solid var(--border);
    border-radius:5px; color:var(--text);
    font-family:'Share Tech Mono',monospace; font-size:15px;
    padding:8px 10px; outline:none; transition:border-color 0.2s;
    -moz-appearance:textfield;
  }
  .field-group input[type="number"]::-webkit-inner-spin-button { -webkit-appearance:none; }
  .field-group input[type="number"]:focus { border-color:#3DFFA0; }

  /* Height */
  .height-row { display:flex; align-items:center; gap:10px; }
  .height-row input[type="range"] {
    flex:1; -webkit-appearance:none; height:6px;
    border-radius:3px; background:var(--border); outline:none; cursor:pointer;
  }
  .height-row input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance:none; width:18px; height:18px;
    border-radius:50%; background:#3DFFA0; cursor:pointer;
    box-shadow:0 0 6px #3DFFA0;
  }
  .height-b input[type="range"]::-webkit-slider-thumb {
    background:var(--accent-b); box-shadow:0 0 6px var(--accent-b);
  }
  .height-val { font-family:'Share Tech Mono',monospace; font-size:15px; color:var(--text); min-width:64px; text-align:right; }

  /* Map-click mode bar */
  .mapclick-bar {
    display:flex; align-items:stretch;
    border:1px solid var(--border); border-radius:7px; overflow:hidden;
    background:rgba(255,255,255,0.02);
  }
  .mapclick-label {
    font-size:15px; color:var(--muted); font-family:'Share Tech Mono',monospace;
    padding:0 12px; border-right:1px solid var(--border);
    display:flex; align-items:center; white-space:nowrap; flex-shrink:0;
  }
  .mc-opt {
    flex:1; padding:10px 6px; border:none; background:none;
    font-family:'Barlow',sans-serif; font-size:14px; font-weight:700;
    letter-spacing:0.05em; text-transform:uppercase;
    cursor:pointer; color:var(--muted); transition:all 0.14s;
  }
  .mc-opt:not(:last-child) { border-right:1px solid var(--border); }
  .mc-opt:hover { color:var(--text); background:rgba(255,255,255,0.04); }
  .mc-opt.sel-off { background:rgba(255,255,255,0.05); color:var(--text); }
  .mc-opt.sel-a   { background:rgba(61,255,160,0.12); color:#3DFFA0; }
  .mc-opt.sel-b   { background:rgba(105,255,71,0.10); color:var(--accent-b); }
  .esc-hint { font-size:14px; color:var(--muted); font-family:'Share Tech Mono',monospace; text-align:center; margin-top:7px; min-height:18px; }

  /* Calc button */
  .calc-btn {
    width:100%; padding:15px;
    background:linear-gradient(135deg,rgba(61,255,160,0.15),rgba(0,112,243,0.15));
    border:1px solid #3DFFA0; border-radius:8px;
    color:#3DFFA0; font-family:'Barlow',sans-serif;
    font-size:17px; font-weight:700; letter-spacing:0.08em; text-transform:uppercase;
    cursor:pointer; transition:all 0.2s;
    display:flex; align-items:center; justify-content:center; gap:10px;
  }
  .calc-btn:hover { background:linear-gradient(135deg,rgba(61,255,160,0.24),rgba(0,112,243,0.24)); box-shadow:0 0 18px rgba(61,255,160,0.18); }
  .calc-btn:active { transform:scale(0.98); }
  .calc-btn:disabled { opacity:0.4; cursor:not-allowed; transform:none; }
  .tip { font-size:15px; color:var(--muted); font-style:italic; text-align:center; padding:7px 0 0; }

  /* Results */
  .stats-grid { display:grid; grid-template-columns:1fr 1fr; gap:10px; }
  .stat-card { background:rgba(255,255,255,0.02); border:1px solid var(--border); border-radius:8px; padding:13px 15px; }
  .stat-card.full { grid-column:1/-1; }
  .stat-label { font-size:15px; font-weight:700; letter-spacing:0.1em; text-transform:uppercase; color:var(--muted); margin-bottom:5px; font-family:'Share Tech Mono',monospace; }
  .stat-value { font-family:'Share Tech Mono',monospace; font-size:18px; color:var(--text); }
  .sv-a    { color:#3DFFA0; }
  .sv-b    { color:var(--accent-b); }
  .sv-warn { color:var(--accent-warn); }

  .los-card { border-radius:10px; padding:16px 18px; display:flex; align-items:center; gap:16px; margin-bottom:12px; }
  .los-excellent { background:rgba(61,255,160,0.06);  border:1px solid rgba(61,255,160,0.35); }
  .los-good      { background:rgba(105,255,71,0.06);  border:1px solid rgba(105,255,71,0.35); }
  .los-fair      { background:rgba(255,224,102,0.06); border:1px solid rgba(255,224,102,0.35); }
  .los-poor      { background:rgba(255,159,67,0.06);  border:1px solid rgba(255,159,67,0.35); }
  .los-unlikely  { background:rgba(255,107,53,0.06);  border:1px solid rgba(255,107,53,0.35); }
  .los-idle      { background:rgba(255,255,255,0.02); border:1px solid var(--border); }
  .los-icon { font-size:28px; }
  .los-text h3 { font-size:18px; font-weight:700; margin-bottom:3px; }
  .los-text p  { font-size:15px; color:var(--muted); line-height:1.4; }
  .los-excellent .los-text h3 { color:#3DFFA0; }
  .los-good      .los-text h3 { color:#69ff47; }
  .los-fair      .los-text h3 { color:#ffe066; }
  .los-poor      .los-text h3 { color:#ff9f43; }
  .los-unlikely  .los-text h3 { color:#ff6b35; }

  /* Link quality meter bar */
  .link-meter { margin-top:11px; }
  .link-meter-label { font-size:15px; color:var(--muted); font-family:'Share Tech Mono',monospace; letter-spacing:0.08em; text-transform:uppercase; margin-bottom:6px; }
  .link-meter-track { height:9px; background:var(--border); border-radius:4px; overflow:hidden; }
  .link-meter-fill  { height:100%; border-radius:4px; transition:width 0.4s ease, background 0.4s ease; }
  .link-diffraction { margin-top:8px; font-size:15px; color:var(--muted); font-family:'Share Tech Mono',monospace; line-height:1.6; }

  /* ‚îÄ‚îÄ LINK BUDGET PANEL ‚îÄ‚îÄ */
  .lb-header {
    display: flex; align-items: center; justify-content: space-between;
    cursor: pointer; user-select: none; padding: 2px 0 10px;
  }
  .lb-toggle-icon {
    font-size: 14px; color: var(--muted);
    font-family: 'Share Tech Mono', monospace; letter-spacing: 0.06em;
  }
  .lb-body { overflow: hidden; }
  .lb-row {
    display: flex; gap: 8px; align-items: center;
    margin-bottom: 10px;
  }
  .lb-row label {
    font-size: 15px; font-weight: 700; letter-spacing: 0.08em;
    text-transform: uppercase; color: var(--muted);
    font-family: 'Share Tech Mono', monospace;
    flex: 0 0 120px; line-height: 1.3;
  }
  .lb-input {
    padding: 9px 10px;
    background: rgba(255,255,255,0.05); border: 1px solid var(--border);
    border-radius: 6px; color: var(--text);
    font-family: 'Share Tech Mono', monospace; font-size: 15px; font-weight: 700;
    outline: none; transition: border-color 0.15s;
    width: 90px; flex-shrink: 0;
  }
  .lb-input:focus { border-color: rgba(61,255,160,0.5); }
  .lb-select {
    flex: 1; padding: 9px 10px;
    background: rgba(255,255,255,0.04); border: 1px solid var(--border);
    border-radius: 6px; color: var(--text);
    font-family: 'Barlow', sans-serif; font-size: 13px; font-weight: 600;
    outline: none; cursor: pointer; min-width: 0;
    -webkit-appearance: none; appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='8' viewBox='0 0 12 8'%3E%3Cpath d='M1 1l5 5 5-5' stroke='%23606870' stroke-width='1.5' fill='none'/%3E%3C/svg%3E");
    background-repeat: no-repeat; background-position: right 10px center;
    padding-right: 28px;
  }
  .lb-select option { background: #161b22; }
  .lb-select optgroup { background: #161b22; color: #3DFFA0; font-size: 11px; font-style: normal; font-weight: 700; letter-spacing: 0.06em; }
  .lb-select:focus { border-color: rgba(61,255,160,0.5); }
  .lb-unit {
    font-size: 14px; font-family: 'Share Tech Mono', monospace;
    color: var(--muted); flex: 0 0 auto; white-space: nowrap;
  }
  /* Unit-mode toggle (dB ‚Üî W, dBd ‚Üî dBi) */
  .lb-unit-toggle {
    display: flex; border: 1px solid var(--border); border-radius: 5px;
    overflow: hidden; flex-shrink: 0;
  }
  .lb-unit-btn {
    padding: 5px 9px; border: none; background: none;
    font-family: 'Share Tech Mono', monospace; font-size: 13px; font-weight: 700;
    letter-spacing: 0.05em; cursor: pointer; color: var(--muted);
    transition: all 0.12s; white-space: nowrap;
  }
  .lb-unit-btn:first-child { border-right: 1px solid var(--border); }
  .lb-unit-btn.lb-unit-active {
    background: rgba(61,255,160,0.14); color: #3DFFA0;
  }
  .lb-divider {
    border: none; border-top: 1px solid var(--border);
    margin: 8px 0 12px;
  }
  .lb-sub {
    font-size: 13px; font-weight: 700; letter-spacing: 0.1em;
    text-transform: uppercase; color: var(--muted); opacity: 0.7;
    font-family: 'Share Tech Mono', monospace; margin-bottom: 10px;
  }
  .lb-erp-row {
    display: flex; align-items: center; justify-content: space-between;
    background: rgba(61,255,160,0.06); border: 1px solid rgba(61,255,160,0.2);
    border-radius: 7px; padding: 10px 14px; margin: 4px 0 14px;
  }
  .lb-erp-label {
    font-size: 15px; font-weight: 700; letter-spacing: 0.07em; text-transform: uppercase;
    color: var(--muted); font-family: 'Share Tech Mono', monospace;
  }
  .lb-erp-val {
    font-family: 'Share Tech Mono', monospace; font-size: 18px; font-weight: 700;
    color: #3DFFA0;
  }
  .lb-convert-note {
    font-size: 11px; color: var(--muted); font-family: 'Share Tech Mono', monospace;
    margin-top: -6px; margin-bottom: 10px; padding-left: 108px; line-height: 1.5;
  }

  /* ‚îÄ‚îÄ LINK BUDGET RESULT CARD ‚îÄ‚îÄ */
  .lbr-card {
    border-radius: 10px; padding: 14px 16px;
    margin-top: 12px; display: none;
  }
  .lbr-card.visible { display: block; }
  .lbr-card.lbr-pass   { background: rgba(61,255,160,0.05);  border: 1px solid rgba(61,255,160,0.3); }
  .lbr-card.lbr-marginal{ background:rgba(255,224,102,0.05); border: 1px solid rgba(255,224,102,0.3); }
  .lbr-card.lbr-fail   { background: rgba(255,107,53,0.05);  border: 1px solid rgba(255,107,53,0.3); }
  .lbr-title {
    font-size: 15px; font-weight: 700; letter-spacing: 0.1em;
    text-transform: uppercase; color: var(--muted);
    font-family: 'Share Tech Mono', monospace; margin-bottom: 10px;
  }
  .lbr-margin-row {
    display: flex; align-items: baseline; gap: 10px; margin-bottom: 12px;
  }
  .lbr-margin-val {
    font-family: 'Share Tech Mono', monospace; font-size: 28px; font-weight: 700;
  }
  .lbr-margin-label {
    font-family: 'Share Tech Mono', monospace; font-size: 13px; color: var(--muted);
  }
  .lbr-verdict {
    font-family: 'Barlow', sans-serif; font-size: 14px; font-weight: 700;
    letter-spacing: 0.06em; text-transform: uppercase; margin-bottom: 12px;
  }
  .lbr-pass   .lbr-margin-val { color: #3DFFA0; }
  .lbr-marginal .lbr-margin-val { color: #ffe066; }
  .lbr-fail   .lbr-margin-val { color: #ff6b35; }
  .lbr-pass   .lbr-verdict { color: #3DFFA0; }
  .lbr-marginal .lbr-verdict { color: #ffe066; }
  .lbr-fail   .lbr-verdict { color: #ff6b35; }
  .lbr-table {
    width: 100%; border-collapse: collapse; font-family: 'Share Tech Mono', monospace;
    font-size: 14px;
  }
  .lbr-table tr { border-bottom: 1px solid rgba(255,255,255,0.04); }
  .lbr-table tr:last-child { border-bottom: none; }
  .lbr-table td { padding: 4px 2px; }
  .lbr-table .td-label { color: var(--muted); }
  .lbr-table .td-sign { width: 20px; text-align: center; }
  .lbr-table .td-val { text-align: right; color: var(--text); white-space: nowrap; }
  .lbr-table .td-val.pos { color: #3DFFA0; }
  .lbr-table .td-val.neg { color: #ff6b35; }
  .lbr-table .td-val.neu { color: #ffe066; }
  .lbr-table tr.lbr-total td { border-top: 1px solid var(--border); padding-top: 8px; font-weight: 700; }
  .lbr-table tr.lbr-footnote td { padding-top: 6px; opacity: 0.45; font-size: 13px; }
  .lbr-table .td-val.muted { color: var(--muted); }
  .lbr-hint {
    font-size: 14px; color: var(--muted); font-family: 'Share Tech Mono', monospace;
    margin-top: 10px; line-height: 1.6;
  }
  .lbr-hint strong { color: var(--text); }

  /* Corrected margin secondary display */
  .lbr-corrected-block {
    margin: 12px 0 4px;
    padding: 10px 12px;
    background: rgba(255,255,255,0.03);
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: 7px;
  }
  .lbr-corrected-label {
    font-size: 10px; font-weight: 700; letter-spacing: 0.1em; text-transform: uppercase;
    color: var(--muted); font-family: 'Share Tech Mono', monospace; margin-bottom: 6px;
  }
  .lbr-corrected-row {
    display: flex; align-items: baseline; gap: 8px; margin-bottom: 4px;
  }
  .lbr-corrected-val {
    font-family: 'Share Tech Mono', monospace; font-size: 22px; font-weight: 700;
  }
  .lbr-corrected-val.pos  { color: #3DFFA0; }
  .lbr-corrected-val.neu  { color: #ffe066; }
  .lbr-corrected-val.neg  { color: #ff6b35; }
  .lbr-corrected-sub {
    font-family: 'Share Tech Mono', monospace; font-size: 11px; color: var(--muted);
    line-height: 1.5;
  }
  .lbr-correction-breakdown {
    font-family: 'Share Tech Mono', monospace; font-size: 13px;
    color: var(--muted); margin-top: 4px; line-height: 1.7;
  }
  .lbr-correction-breakdown span { color: #ff9f43; }

  /* Freq band selector */
  .freq-bar {
    display:flex; align-items:stretch;
    border:1px solid var(--border); border-radius:7px; overflow:hidden;
    background:rgba(255,255,255,0.02); margin-bottom:14px;
  }
  .freq-label {
    font-size:15px; color:var(--muted); font-family:'Share Tech Mono',monospace;
    padding:0 12px; border-right:1px solid var(--border);
    display:flex; align-items:center; white-space:nowrap; flex-shrink:0;
  }
  .freq-opt {
    flex:1; padding:10px 4px; border:none; background:none;
    font-family:'Barlow',sans-serif; font-size:15px; font-weight:700;
    letter-spacing:0.04em; text-transform:uppercase;
    cursor:pointer; color:var(--muted); transition:all 0.14s; text-align:center;
  }
  .freq-opt:not(:last-child) { border-right:1px solid var(--border); }
  .freq-opt:hover { color:var(--text); background:rgba(255,255,255,0.04); }
  .freq-opt.freq-sel { background:rgba(61,255,160,0.12); color:#3DFFA0; }

  /* ‚îÄ‚îÄ MAP ‚îÄ‚îÄ */
  #map-wrap {
    grid-column: 2; grid-row: 1;
    position: relative;
    min-width: 0; min-height: 0;
    overflow: hidden;
  }
  #map {
    width: 100%; height: 100%;
    position: absolute; inset: 0;
  }
  #map.clickmode-a,
  #map.clickmode-b { cursor: crosshair !important; }

  #map.clickmode-a .leaflet-container,
  #map.clickmode-b .leaflet-container { cursor: crosshair !important; }

  .map-hint {
    position:absolute; bottom:16px; left:50%; transform:translateX(-50%);
    background:rgba(13,17,23,0.92); border:1px solid var(--border);
    border-radius:24px; padding:9px 22px;
    font-size:15px; font-family:'Share Tech Mono',monospace;
    color:var(--text); z-index:900; pointer-events:none;
    white-space:nowrap; transition:opacity 0.2s;
  }
  .map-hint.hidden  { opacity:0; }
  .map-hint.hint-a  { border-color:#3DFFA0; color:#3DFFA0; }
  .map-hint.hint-b  { border-color:var(--accent-b); color:var(--accent-b); }

  /* ‚îÄ‚îÄ CHART ‚îÄ‚îÄ */
  .chart-wrap {
    grid-column: 2; grid-row: 2;
    background: var(--surface); border-top: 1px solid var(--border);
    padding: 12px 18px 16px;
    display: flex; flex-direction: column;
    min-width: 0; min-height: 0;
    overflow: hidden;
  }
  .chart-header { display:flex; align-items:center; justify-content:space-between; margin-bottom:9px; flex-shrink:0; }
  .chart-title  { font-size:15px; font-weight:700; letter-spacing:0.1em; text-transform:uppercase; color:var(--muted); }
  .chart-legend { display:flex; gap:16px; font-size:15px; color:var(--muted); font-family:'Share Tech Mono',monospace; flex-wrap:wrap; }
  .leg { display:flex; align-items:center; gap:5px; }
  .leg-sw { width:22px; height:3px; border-radius:1px; }
  canvas#elevChart { flex:1; min-height:0; width:100% !important; cursor:crosshair; }

  /* ‚îÄ‚îÄ LOADING ‚îÄ‚îÄ */
  .loading-overlay {
    position:fixed; inset:0; background:rgba(13,17,23,0.85);
    z-index:9999; display:flex; align-items:center; justify-content:center;
    flex-direction:column; gap:18px;
    font-family:'Share Tech Mono',monospace; font-size:16px; color:#3DFFA0;
  }
  .spinner { width:48px; height:48px; border:3px solid var(--border); border-top-color:#3DFFA0; border-radius:50%; animation:spin 0.8s linear infinite; }
  @keyframes spin { to { transform:rotate(360deg); } }
  .loading-overlay.hidden { display:none; }

  .info-note { font-size:15px; color:var(--muted); line-height:1.8; font-family:'Share Tech Mono',monospace; }
  .api-note  { font-size:15px; color:var(--muted); line-height:1.7; font-family:'Share Tech Mono',monospace; background:rgba(255,107,53,0.06); border:1px solid rgba(255,107,53,0.2); border-radius:6px; padding:11px 13px; margin-top:8px; }

  /* ‚îÄ‚îÄ LAYER SWITCHER ‚îÄ‚îÄ */
  .layer-switcher {
    position: absolute;
    top: 12px; right: 12px;
    z-index: 800;
    display: flex;
    flex-direction: column;
    gap: 5px;
    pointer-events: all;
  }
  .ls-btn {
    display: flex; align-items: center; gap: 8px;
    padding: 9px 14px;
    background: rgba(13,17,23,0.88);
    border: 1px solid var(--border);
    border-radius: 7px;
    color: var(--muted);
    font-family: 'Barlow', sans-serif;
    font-size: 14px; font-weight: 600;
    letter-spacing: 0.04em; text-transform: uppercase;
    cursor: pointer; transition: all 0.16s;
    white-space: nowrap;
    backdrop-filter: blur(6px);
  }
  .ls-btn:hover { color: var(--text); border-color: var(--muted); }
  .ls-btn.active { color: #3DFFA0; border-color: #3DFFA0; background: rgba(61,255,160,0.1); }
  .ls-swatch {
    width: 18px; height: 18px; border-radius: 4px;
    border: 1px solid rgba(255,255,255,0.2); flex-shrink: 0;
  }

  /* ‚îÄ‚îÄ GOOGLE KEY SECTION ‚îÄ‚îÄ */
  .gkey-row { display: flex; gap: 7px; margin-top: 9px; }
  .gkey-row input[type="text"] {
    flex: 1; background: var(--bg); border: 1px solid var(--border);
    border-radius: 5px; color: var(--text);
    font-family: 'Share Tech Mono', monospace; font-size: 14px;
    padding: 8px 12px; outline: none; transition: border-color 0.2s;
  }
  .gkey-row input[type="text"]::placeholder { color: var(--muted); opacity: 0.5; }
  .gkey-row input[type="text"]:focus { border-color: #3DFFA0; }
  .gkey-apply {
    padding: 8px 15px;
    background: rgba(61,255,160,0.08); border: 1px solid #3DFFA0;
    border-radius: 5px; color: #3DFFA0;
    font-family: 'Barlow', sans-serif; font-size: 14px; font-weight: 700;
    letter-spacing: 0.04em; cursor: pointer; transition: all 0.16s;
    white-space: nowrap;
  }
  .gkey-apply:hover { background: rgba(61,255,160,0.16); }
  .gkey-status { font-size: 14px; font-family: 'Share Tech Mono', monospace; color: var(--muted); margin-top: 6px; min-height: 18px; }
  .gkey-status.ok  { color: var(--accent-b); }
  .gkey-status.err { color: var(--accent-warn); }

  /* ‚îÄ‚îÄ MOBILE TAB BAR (appearance only ‚Äî layout driven by JS) ‚îÄ‚îÄ */
  .mob-tabbar {
    display: none;   /* JS shows this on mobile */
    position: fixed;
    bottom: 0; left: 0; right: 0;
    height: 72px;
    background: #f0f2f0;
    border-top: 3px solid #3DFFA0;
    box-shadow: 0 -4px 24px rgba(0,0,0,0.55);
    z-index: 2000;
  }
  .mob-tab {
    flex: 1;
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    gap: 5px;
    background: none; border: none;
    color: #555e58;
    font-family: 'Barlow', sans-serif;
    font-size: 12px; font-weight: 800;
    letter-spacing: 0.06em; text-transform: uppercase;
    cursor: pointer;
    transition: background 0.15s, color 0.15s;
    padding: 0;
    -webkit-tap-highlight-color: transparent;
  }
  .mob-tab-icon { font-size: 22px; line-height: 1; }
  .mob-tab.active {
    color: #0a7a47;
    background: rgba(61,255,160,0.18);
  }
  .mob-tab + .mob-tab { border-left: 1px solid #cdd1cd; }


  /* ‚îÄ‚îÄ GRID SQUARE LOOKUP ‚îÄ‚îÄ */
  .grid-sq-desc {
    font-size: 14px; color: var(--muted); font-family: 'Share Tech Mono', monospace;
    line-height: 1.6; margin-bottom: 12px;
  }
  .grid-sq-desc code {
    background: rgba(61,255,160,0.1); border: 1px solid rgba(61,255,160,0.25);
    border-radius: 3px; padding: 1px 5px; color: #3DFFA0;
    font-family: 'Share Tech Mono', monospace;
  }
  .grid-row {
    display: flex; gap: 8px; align-items: stretch; margin-bottom: 8px;
  }
  .grid-input {
    flex: 1; padding: 10px 12px;
    background: rgba(255,255,255,0.04); border: 1px solid var(--border);
    border-radius: 7px; color: var(--text);
    font-family: 'Share Tech Mono', monospace; font-size: 20px;
    font-weight: 700; letter-spacing: 0.18em; text-transform: uppercase;
    outline: none; transition: border-color 0.15s;
  }
  .grid-input::placeholder { font-size: 14px; letter-spacing: 0.04em; font-weight: 400; color: var(--muted); }
  .grid-input:focus { border-color: rgba(61,255,160,0.5); }
  .grid-btn {
    padding: 10px 18px;
    background: rgba(61,255,160,0.1); border: 1px solid rgba(61,255,160,0.4);
    border-radius: 7px; color: #3DFFA0;
    font-family: 'Barlow', sans-serif; font-size: 14px; font-weight: 700;
    letter-spacing: 0.06em; cursor: pointer; white-space: nowrap;
    transition: all 0.15s; display: flex; align-items: center; gap: 6px;
  }
  .grid-btn:hover { background: rgba(61,255,160,0.18); }
  .grid-btn:disabled { opacity: 0.4; cursor: not-allowed; }
  .grid-status {
    font-size: 14px; font-family: 'Share Tech Mono', monospace;
    color: var(--muted); margin-bottom: 8px; min-height: 18px;
  }
  .grid-status.ok  { color: #3DFFA0; }
  .grid-status.err { color: var(--accent-warn); }
  .grid-card {
    background: rgba(61,255,160,0.04); border: 1px solid rgba(61,255,160,0.22);
    border-radius: 9px; padding: 13px 14px; margin-bottom: 10px; display: none;
  }
  .grid-card.visible { display: block; }
  .grid-card-sq {
    font-family: 'Share Tech Mono', monospace; font-size: 22px; font-weight: 700;
    color: #3DFFA0; letter-spacing: 0.18em; margin-bottom: 4px;
  }
  .grid-card-info {
    font-size: 14px; color: var(--text); margin-bottom: 8px;
    font-family: 'Share Tech Mono', monospace;
  }
  .grid-card-note {
    font-size: 13px; color: var(--muted); font-family: 'Share Tech Mono', monospace;
    line-height: 1.5;
  }
  /* ‚îÄ‚îÄ REPEATER LOOKUP ‚îÄ‚îÄ */
  .site-mode-row {
    display: flex; gap: 0;
    border: 1px solid var(--border); border-radius: 7px;
    overflow: hidden; margin-bottom: 14px;
    background: rgba(255,255,255,0.02);
  }
  .site-mode-btn {
    flex: 1; padding: 9px 4px;
    border: none; background: none;
    font-family: 'Barlow', sans-serif; font-size: 14px;
    font-weight: 700; letter-spacing: 0.05em; text-transform: uppercase;
    cursor: pointer; color: var(--muted); transition: all 0.14s;
    display: flex; align-items: center; justify-content: center; gap: 6px;
  }
  .site-mode-btn:not(:last-child) { border-right: 1px solid var(--border); }
  .site-mode-btn:hover { color: var(--text); background: rgba(255,255,255,0.04); }
  .site-mode-btn.mode-active {
    background: rgba(61,255,160,0.12); color: #3DFFA0;
  }
  .rptr-row {
    display: grid;
    grid-template-columns: 1fr auto auto;
    gap: 8px; align-items: stretch; margin-bottom: 8px;
  }
  /* If the row is too cramped (mobile/narrow panel), stack callsign+type on row 1, button on row 2 */
  @media (max-width: 400px) {
    .rptr-row {
      grid-template-columns: 1fr auto;
      grid-template-rows: auto auto;
    }
    .rptr-btn { grid-column: 1 / -1; }
  }
  .rptr-callsign {
    flex: 1; padding: 10px 12px;
    background: rgba(255,255,255,0.04); border: 1px solid var(--border);
    border-radius: 7px; color: var(--text);
    font-family: 'Share Tech Mono', monospace; font-size: 16px;
    font-weight: 700; letter-spacing: 0.12em; text-transform: uppercase;
    outline: none; transition: border-color 0.15s;
  }
  .rptr-callsign::placeholder { font-size: 13px; letter-spacing: 0.04em; text-transform: none; font-weight: 400; color: var(--muted); }
  .rptr-callsign:focus { border-color: rgba(61,255,160,0.5); }
  .rptr-type {
    padding: 10px 8px;
    background: rgba(255,255,255,0.04); border: 1px solid var(--border);
    border-radius: 7px; color: var(--muted);
    font-family: 'Barlow', sans-serif; font-size: 14px; font-weight: 700;
    letter-spacing: 0.03em; text-transform: uppercase;
    cursor: pointer; outline: none;
    min-width: 0; max-width: 110px;
  }
  .rptr-type option { background: #161b22; }
  .rptr-btn {
    padding: 10px 16px;
    background: rgba(61,255,160,0.1); border: 1px solid rgba(61,255,160,0.4);
    border-radius: 7px; color: #3DFFA0;
    font-family: 'Barlow', sans-serif; font-size: 14px; font-weight: 700;
    letter-spacing: 0.04em; cursor: pointer; white-space: nowrap;
    transition: all 0.15s; display: flex; align-items: center; gap: 6px;
  }
  .rptr-btn:hover { background: rgba(61,255,160,0.18); }
  .rptr-btn:disabled { opacity: 0.4; cursor: not-allowed; }
  .rptr-status {
    font-size: 14px; font-family: 'Share Tech Mono', monospace;
    color: var(--muted); margin-bottom: 8px; min-height: 16px;
  }
  .rptr-status.ok  { color: #3DFFA0; }
  .rptr-status.err { color: var(--accent-warn); }
  .rptr-card {
    background: rgba(61,255,160,0.04);
    border: 1px solid rgba(61,255,160,0.22);
    border-radius: 9px; padding: 13px 14px;
    margin-bottom: 10px; display: none;
  }
  .rptr-card.visible { display: block; }
  .rptr-card-call {
    font-family: 'Share Tech Mono', monospace;
    font-size: 18px; font-weight: 700;
    color: #3DFFA0; letter-spacing: 0.1em; margin-bottom: 6px;
  }
  .rptr-card-freq {
    font-family: 'Share Tech Mono', monospace;
    font-size: 14px; color: var(--text); margin-bottom: 4px;
  }
  .rptr-card-loc {
    font-size: 15px; color: var(--muted); margin-bottom: 8px;
  }
  .rptr-badges { display: flex; gap: 6px; flex-wrap: wrap; }
  .rptr-badge {
    font-size: 13px; font-weight: 700; letter-spacing: 0.08em;
    text-transform: uppercase; padding: 3px 8px; border-radius: 4px;
    font-family: 'Share Tech Mono', monospace;
  }
  .rptr-badge-open   { background: rgba(61,255,160,0.12); color: #3DFFA0; border: 1px solid rgba(61,255,160,0.3); }
  .rptr-badge-closed { background: rgba(255,107,53,0.12); color: #ff6b35; border: 1px solid rgba(255,107,53,0.3); }
  .rptr-badge-mode   { background: rgba(105,255,71,0.10); color: #69ff47; border: 1px solid rgba(105,255,71,0.25); }
  .rptr-badge-gmrs   { background: rgba(255,224,102,0.10); color: #ffe066; border: 1px solid rgba(255,224,102,0.3); }
  .rptr-picker {
    margin-bottom: 8px; display: none;
  }
  .rptr-picker.visible { display: block; }
  .rptr-picker-label {
    font-size: 13px; color: var(--muted); font-family: 'Share Tech Mono', monospace;
    letter-spacing: 0.07em; text-transform: uppercase; margin-bottom: 6px;
  }
  .rptr-picker select {
    width: 100%; padding: 8px 10px;
    background: rgba(255,255,255,0.04); border: 1px solid var(--border);
    border-radius: 7px; color: var(--text);
    font-family: 'Share Tech Mono', monospace; font-size: 14px;
    outline: none; cursor: pointer;
  }
  .rptr-picker select option { background: #161b22; }
  .rptr-proxy-note {
    font-size: 13px; color: var(--accent-warn);
    font-family: 'Share Tech Mono', monospace;
    background: rgba(255,107,53,0.07); border: 1px solid rgba(255,107,53,0.25);
    border-radius: 6px; padding: 8px 10px; margin-bottom: 10px; display: none;
    line-height: 1.5;
  }

  /* ‚îÄ‚îÄ LICENSEE LOOKUP ‚îÄ‚îÄ */
  .lic-row {
    display: flex; gap: 8px; align-items: stretch; margin-bottom: 8px;
  }
  .lic-callsign {
    flex: 1; padding: 10px 12px;
    background: rgba(255,255,255,0.04); border: 1px solid var(--border);
    border-radius: 7px; color: var(--text);
    font-family: 'Share Tech Mono', monospace; font-size: 16px;
    font-weight: 700; letter-spacing: 0.12em; text-transform: uppercase;
    outline: none; transition: border-color 0.15s;
  }
  .lic-callsign::placeholder { font-size: 13px; letter-spacing: 0.04em;
    text-transform: none; font-weight: 400; color: var(--muted); }
  .lic-callsign:focus { border-color: rgba(255,224,102,0.5); }
  .lic-btn {
    padding: 10px 16px;
    background: rgba(255,224,102,0.1); border: 1px solid rgba(255,224,102,0.4);
    border-radius: 7px; color: #ffe066;
    font-family: 'Barlow', sans-serif; font-size: 14px; font-weight: 700;
    letter-spacing: 0.04em; cursor: pointer; white-space: nowrap;
    transition: all 0.15s; display: flex; align-items: center; gap: 6px;
  }
  .lic-btn:hover { background: rgba(255,224,102,0.18); }
  .lic-btn:disabled { opacity: 0.4; cursor: not-allowed; }
  .lic-status {
    font-size: 14px; font-family: 'Share Tech Mono', monospace;
    color: var(--muted); margin-bottom: 8px; min-height: 16px;
  }
  .lic-status.ok  { color: #ffe066; }
  .lic-status.err { color: var(--accent-warn); }
  .lic-card {
    background: rgba(255,224,102,0.04);
    border: 1px solid rgba(255,224,102,0.22);
    border-radius: 9px; padding: 13px 14px;
    margin-bottom: 10px; display: none;
  }
  .lic-card.visible { display: block; }
  .lic-card-call {
    font-family: 'Share Tech Mono', monospace;
    font-size: 18px; font-weight: 700;
    color: #ffe066; letter-spacing: 0.1em; margin-bottom: 4px;
  }
  .lic-card-name {
    font-size: 15px; color: var(--text); margin-bottom: 4px;
  }
  .lic-card-addr {
    font-size: 15px; color: var(--muted); margin-bottom: 8px; line-height: 1.5;
  }
  .lic-card-note {
    font-size: 15px; color: var(--muted); font-family: 'Share Tech Mono', monospace;
    font-style: italic;
  }
  .lic-badges { display: flex; gap: 6px; flex-wrap: wrap; margin-bottom: 6px; }
  .lic-badge {
    font-size: 10px; font-weight: 700; letter-spacing: 0.08em;
    text-transform: uppercase; padding: 3px 8px; border-radius: 4px;
    font-family: 'Share Tech Mono', monospace;
  }
  .lic-badge-ham  { background: rgba(61,255,160,0.12); color: #3DFFA0;
                    border: 1px solid rgba(61,255,160,0.3); }
  .lic-badge-gmrs { background: rgba(255,224,102,0.12); color: #ffe066;
                    border: 1px solid rgba(255,224,102,0.3); }
  .lic-badge-class { background: rgba(105,255,71,0.10); color: #69ff47;
                     border: 1px solid rgba(105,255,71,0.25); }

</style>
</head>
<body>

<div class="app-shell">

  <!-- HEADER -->
  <div class="header">
    <div class="header-icon">
      <svg width="32" height="32" viewBox="0 0 44 44" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M 2 38 L 8 28 L 14 32 L 20 20 L 26 28 L 32 22 L 38 26 L 42 38 Z" fill="#3DFFA0" opacity="0.07"/>
        <path d="M 2 38 L 8 28 L 14 32 L 20 20 L 26 28 L 32 22 L 38 26 L 42 38" stroke="#7d8590" stroke-width="1.5" fill="none" stroke-linejoin="round" opacity="0.6"/>
        <path d="M 4 14 C 7 10, 10 18, 13 14 C 16 10, 19 18, 22 14 C 25 10, 28 18, 31 14 C 34 10, 37 18, 40 14" stroke="#3DFFA0" stroke-width="2" fill="none" stroke-linecap="round"/>
        <circle cx="4" cy="14" r="3" fill="#3DFFA0"/>
        <circle cx="40" cy="14" r="3" fill="#3DFFA0"/>
        <line x1="4"  y1="17" x2="4"  y2="28" stroke="#3DFFA0" stroke-width="1.2" opacity="0.4" stroke-dasharray="2 2"/>
        <line x1="40" y1="17" x2="40" y2="26" stroke="#3DFFA0" stroke-width="1.2" opacity="0.4" stroke-dasharray="2 2"/>
      </svg>
    </div>
    <div>
      <h1>Mike's RF Line of Sight Tool</h1>
      <p>Developed by N4MXB</p>
    </div>
    <div class="status-badge">
      <span id="headerBadge" class="badge badge-idle">IDLE</span>
    </div>
  </div>

  <!-- MAIN GRID -->
  <div class="main">

    <!-- ‚ïê‚ïê PANEL ‚ïê‚ïê -->
    <div class="panel">

      <!-- Map click mode -->
      <div class="section">
        <div class="section-title">Map Click ‚Äî Place Sites</div>
        <div class="mapclick-bar">
          <span class="mapclick-label">üìç Click sets</span>
          <button class="mc-opt sel-off" id="modeOff" onclick="setMapMode('off')">Off</button>
          <button class="mc-opt"         id="modeA"   onclick="setMapMode('a')">Site A</button>
          <button class="mc-opt"         id="modeB"   onclick="setMapMode('b')">Site B</button>
        </div>
        <div class="esc-hint" id="escHint"></div>
      </div>

      <!-- Site A -->
      <div class="section">
        <div class="section-title">Site A ‚Äî Transmitter</div>
        <div class="site-block">
          <div class="site-header">
            <div class="site-dot site-dot-a"></div>
            <span class="site-label label-a">Site Alpha</span>
          </div>
          <div class="action-row">
            <button class="icon-btn" id="gpsA" onclick="useMyLocation('a')">üéØ My Location</button>
            <button class="icon-btn" id="mapBtnA" onclick="setMapMode('a')">üó∫ Pick on Map</button>
          </div>
          <div class="address-row">
            <input type="text" id="addrA" placeholder="Address or place name‚Ä¶" onkeydown="if(event.key==='Enter')geocode('a')">
            <button class="addr-btn" onclick="geocode('a')" title="Search">üîç</button>
          </div>
          <div class="addr-status" id="addrStatusA"></div>
          <div class="coord-row">
            <div class="field-group"><label>Latitude</label><input type="number" id="latA" step="0.0001" value="39.8283"></div>
            <div class="field-group"><label>Longitude</label><input type="number" id="lngA" step="0.0001" value="-98.5795"></div>
          </div>
          <div class="field-group">
            <label>Antenna Height (ft AGL)</label>
            <div class="height-row height-a">
              <input type="range" id="heightRangeA" min="0" max="500" value="33" step="1">
              <span class="height-val" id="heightValA">33 ft</span>
            </div>
            <input type="number" id="heightA" value="33" min="0" max="1640" step="1" style="margin-top:5px;">
          </div>
        </div>
      </div>

      <!-- Site B -->
      <div class="section">
        <div class="section-title">Site B ‚Äî Receiver</div>
        <div class="site-block">
          <div class="site-header">
            <div class="site-dot site-dot-b"></div>
            <span class="site-label label-b">Site Bravo</span>
          </div>

          <!-- Mode toggle -->
          <div class="site-mode-row">
            <button class="site-mode-btn mode-active" id="siteBModeManual" onclick="setSiteBMode('manual')">
              üìç Manual
            </button>
            <button class="site-mode-btn" id="siteBModeRepeater" onclick="setSiteBMode('repeater')">
              üì° Repeater
            </button>
            <button class="site-mode-btn" id="siteBModeLicensee" onclick="setSiteBMode('licensee')">
              üë§ Licensee
            </button>
            <button class="site-mode-btn" id="siteBModeGrid" onclick="setSiteBMode('grid')">
              üî≤ Grid Sq.
            </button>
          </div>

          <!-- Manual entry (default) -->
          <div id="siteBManual">
            <div class="action-row">
              <button class="icon-btn" id="gpsB" onclick="useMyLocation('b')">üéØ My Location</button>
              <button class="icon-btn" id="mapBtnB" onclick="setMapMode('b')">üó∫ Pick on Map</button>
            </div>
            <div class="address-row">
              <input type="text" id="addrB" placeholder="Address or place name‚Ä¶" onkeydown="if(event.key==='Enter')geocode('b')">
              <button class="addr-btn" onclick="geocode('b')" title="Search">üîç</button>
            </div>
            <div class="addr-status" id="addrStatusB"></div>
          </div>

          <!-- Repeater lookup -->
          <div id="siteBRepeater" style="display:none;">
            <div class="rptr-proxy-note" id="rptrProxyNote">
              ‚ö† Repeater proxy not configured. Deploy the Cloudflare Worker and set
              REPEATER_PROXY in the HTML. See cloudflare-worker.js for instructions.
            </div>
            <div class="rptr-row">
              <input class="rptr-callsign" type="text" id="rptrCallsign"
                placeholder="Callsign e.g. W4XYZ"
                onkeydown="if(event.key==='Enter')lookupRepeater()"
                oninput="this.value=this.value.toUpperCase()">
              <select class="rptr-type" id="rptrType" title="Repeater type">
                <option value="amateur">Amateur</option>
                <option value="gmrs">GMRS</option>
              </select>
              <button class="rptr-btn" id="rptrLookupBtn" onclick="lookupRepeater()">
                üîç Look Up
              </button>
            </div>
            <div class="rptr-status" id="rptrStatus"></div>

            <!-- Multi-result picker (shown when callsign has multiple repeaters) -->
            <div class="rptr-picker" id="rptrPicker">
              <div class="rptr-picker-label">Multiple repeaters found ‚Äî select one:</div>
              <select id="rptrPickerSelect" onchange="selectRepeaterResult(this.value)"></select>
            </div>

            <!-- Result card -->
            <div class="rptr-card" id="rptrCard">
              <div class="rptr-card-call" id="rptrCardCall">‚Äî</div>
              <div class="rptr-card-freq" id="rptrCardFreq">‚Äî</div>
              <div class="rptr-card-loc"  id="rptrCardLoc">‚Äî</div>
              <div class="rptr-badges"    id="rptrCardBadges"></div>
            </div>

            <div class="addr-status" id="addrStatusBRepeater"></div>
          </div>

          <!-- Licensee lookup (ham or GMRS operator by callsign) -->
          <div id="siteBLicensee" style="display:none;">
            <p style="font-size:12px;color:var(--muted);margin:0 0 10px;line-height:1.5;">
              Enter any <strong style="color:#3DFFA0">amateur (ham)</strong> or
              <strong style="color:#ffe066">GMRS</strong> callsign to look up the
              licensee's address and plot it as Point B.
            </p>
            <div class="lic-row">
              <input class="lic-callsign" type="text" id="licCallsign"
                placeholder="e.g. N4MXB or WQXX1234"
                onkeydown="if(event.key==='Enter')lookupLicensee()"
                oninput="this.value=this.value.toUpperCase()">
              <button class="lic-btn" id="licLookupBtn" onclick="lookupLicensee()">
                üîç Look Up
              </button>
            </div>
            <div class="lic-status" id="licStatus"></div>
            <div class="lic-card" id="licCard">
              <div class="lic-badges" id="licCardBadges"></div>
              <div class="lic-card-call" id="licCardCall">‚Äî</div>
              <div class="lic-card-name" id="licCardName">‚Äî</div>
              <div class="lic-card-addr" id="licCardAddr">‚Äî</div>
              <div class="lic-card-note" id="licCardNote"></div>
            </div>
            <div class="addr-status" id="addrStatusBLicensee"></div>
          </div>

          <!-- Grid Square lookup -->
          <div id="siteBGrid" style="display:none;">
            <p class="grid-sq-desc">
              Enter a <strong style="color:#3DFFA0">Maidenhead grid square</strong>
              (4 or 6 characters, e.g. <code>EM74</code> or <code>EM74rj</code>).
              The marker will be placed at the center of that grid square.
            </p>
            <div class="grid-row">
              <input class="grid-input" type="text" id="gridInput"
                placeholder="e.g. EM74rj"
                maxlength="6"
                onkeydown="if(event.key==='Enter')lookupGridSquare()"
                oninput="this.value=this.value.toUpperCase()">
              <button class="grid-btn" id="gridLookupBtn" onclick="lookupGridSquare()">
                üî≤ Go
              </button>
            </div>
            <div class="grid-status" id="gridStatus"></div>
            <div class="grid-card" id="gridCard">
              <div class="grid-card-sq" id="gridCardSq">‚Äî</div>
              <div class="grid-card-info" id="gridCardInfo">‚Äî</div>
              <div class="grid-card-note">üìç Marker placed at grid square center ¬∑ precision ‚âà 3‚Äì70 mi depending on grid size</div>
            </div>
          </div>

          <!-- Shared: coordinates + antenna height -->
          <div class="coord-row">
            <div class="field-group"><label>Latitude</label><input type="number" id="latB" step="0.0001" value="39.9283"></div>
            <div class="field-group"><label>Longitude</label><input type="number" id="lngB" step="0.0001" value="-98.4795"></div>
          </div>
          <div class="field-group">
            <label>Antenna Height (ft AGL)</label>
            <div class="height-row height-b">
              <input type="range" id="heightRangeB" min="0" max="500" value="33" step="1">
              <span class="height-val" id="heightValB">33 ft</span>
            </div>
            <input type="number" id="heightB" value="33" min="0" max="1640" step="1" style="margin-top:5px;">
          </div>
        </div>
      </div>

      <!-- Link Budget -->
      <div class="section" id="lbSection">
        <div class="lb-header" onclick="toggleLinkBudget()" title="Expand / collapse">
          <div style="display:flex;flex-direction:column;gap:4px;">
            <div class="section-title" style="margin:0;">‚ö° Transmitter Power / Antenna Gain</div>
            <div class="lb-sub" id="lbCollapsedPeek" style="margin:0;opacity:0.7;">üì° My Station ‚Äî Transmitter (Site A)</div>
          </div>
          <span class="lb-toggle-icon" id="lbToggleIcon">‚ñº EXPAND</span>
        </div>
        <div class="lb-body" id="lbBody" style="display:none;">

          <!-- ‚îÄ‚îÄ TRANSMITTER (Site A) ‚îÄ‚îÄ -->
          <div class="lb-sub">üì° My Station ‚Äî Transmitter (Site A)</div>

          <!-- TX Power -->
          <div class="lb-row">
            <label>TX Output</label>
            <input class="lb-input" id="lbTxPow" type="number" min="0.1" max="1500" step="1" value="5"
              oninput="lbUpdateDerived()">
            <span class="lb-unit">watts</span>
          </div>

          <!-- TX Feedline Loss ‚Äî dB or watts toggle -->
          <div class="lb-row">
            <label>Line Loss</label>
            <input class="lb-input" id="lbTxLossVal" type="number" min="0" max="20" step="0.1" value="1.5"
              oninput="lbUpdateDerived()">
            <div class="lb-unit-toggle">
              <button class="lb-unit-btn lb-unit-active" id="lbTxLossUnitDb"  onclick="lbSetLossUnit('db')">dB</button>
              <button class="lb-unit-btn"                id="lbTxLossUnitW"   onclick="lbSetLossUnit('w')">W lost</button>
            </div>
          </div>
          <div class="lb-convert-note" id="lbTxLossNote">‚âà 71% efficient ¬∑ delivering ~3.5 W to antenna</div>

          <!-- TX Antenna Gain ‚Äî dBd or dBi toggle -->
          <div class="lb-row">
            <label>TX Antenna</label>
            <select class="lb-select" id="lbTxAnt" onchange="lbAntennaChange()">
              <option value="0">HT rubber duck / whip ‚Äî 0 dBd (0 dBi) ¬∑ or similar</option>
              <optgroup label="‚îÄ‚îÄ Comet Fiberglass Omni ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ">
              <option value="2.35">Comet GP-3 ‚Äî 2.35 dBd (4.5 dBi) ¬∑ 2m/70cm, 6 ft ¬∑ or similar</option>
              <option value="4.35">Comet CX-333 ‚Äî 4.35 dBd (6.5 dBi) ¬∑ 2m/1.25m/70cm triband, 10 ft ¬∑ or similar</option>
              <option value="4.35">Comet GP-6 ‚Äî 4.35 dBd (6.5 dBi) ¬∑ 2m/70cm, 10 ft ¬∑ or similar</option>
              <option value="6.35">Comet GP-9 ‚Äî 6.35 dBd (8.5 dBi) ¬∑ 2m/70cm, 17 ft ¬∑ or similar</option>
              <option value="6.85">Comet CA-712 ‚Äî 6.85 dBd (9.0 dBi) ¬∑ UHF/GMRS 460‚Äì470 MHz, 10 ft ¬∑ or similar</option>
              </optgroup>
              <optgroup label="‚îÄ‚îÄ Yagi / Directional ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ">
              <option value="5">Yagi 3-el ‚Äî 5 dBd (7.15 dBi) ¬∑ or similar</option>
              <option value="9">Yagi 5-el ‚Äî 9 dBd (11.15 dBi) ¬∑ or similar</option>
              <option value="12">Yagi 9-el ‚Äî 12 dBd (14.15 dBi) ¬∑ or similar</option>
              </optgroup>
              <option value="custom">Enter custom gain‚Ä¶</option>
            </select>
          </div>
          <div class="lb-row" id="lbTxAntCustomRow" style="display:none;">
            <label>TX Gain</label>
            <input class="lb-input" id="lbTxAntCustom" type="number" min="-3" max="30" step="0.1" value="4"
              oninput="lbUpdateDerived()">
            <div class="lb-unit-toggle">
              <button class="lb-unit-btn lb-unit-active" id="lbTxAntUnitDbd" onclick="lbSetAntUnit('dbd')">dBd</button>
              <button class="lb-unit-btn"                id="lbTxAntUnitDbi" onclick="lbSetAntUnit('dbi')">dBi</button>
            </div>
          </div>
          <div class="lb-convert-note" id="lbTxAntNote" style="display:none;"></div>

          <!-- ERP readout -->
          <div class="lb-erp-row">
            <div class="lb-erp-label">Effective Radiated Power (ERP)</div>
            <div class="lb-erp-val" id="lbErpVal">‚Äî W</div>
          </div>

          <hr class="lb-divider">

          <!-- ‚îÄ‚îÄ RECEIVER (Site B) ‚îÄ‚îÄ -->
          <div class="lb-sub">üìª Their Station ‚Äî Receiver (Site B)</div>

          <!-- RX Sensitivity -->
          <div class="lb-row">
            <label>RX Sensitivity</label>
            <select class="lb-select" id="lbRxSens" onchange="lbSensChange()">
              <option value="-107">HT / handheld (‚àí107 dBm)</option>
              <option value="-110">Mid-range mobile (‚àí110 dBm)</option>
              <option value="-116">Commercial repeater (‚àí116 dBm)</option>
              <option value="-120">Sensitive receiver (‚àí120 dBm)</option>
              <option value="-130">SDR / high-perf (‚àí130 dBm)</option>
              <option value="custom">Custom‚Ä¶</option>
            </select>
          </div>
          <div class="lb-row" id="lbRxSensCustomRow" style="display:none;">
            <label>Sensitivity</label>
            <input class="lb-input" id="lbRxSensCustom" type="number" min="-160" max="-50" step="1" value="-107"
              oninput="lbUpdateDerived()">
            <span class="lb-unit">dBm</span>
          </div>

        </div><!-- /lb-body -->
      </div>

      <!-- Calculate -->
      <div class="section">
        <button class="calc-btn" id="calcBtn" onclick="runAnalysis()">
          <span>‚ö°</span> Calculate Line of Sight
        </button>
        <p class="tip">Drag markers ¬∑ click map ¬∑ enter address ¬∑ or use GPS</p>
      </div>

      <!-- Frequency Band -->
      <div class="section">
        <div class="section-title">RF Band</div>
        <div class="freq-bar">
          <span class="freq-label">üìª Band</span>
          <button class="freq-opt" id="fVLow"  onclick="setFreqBand('vhf-low')"  title="VHF Low: 30‚Äì88 MHz">VHF Lo</button>
          <button class="freq-opt freq-sel" id="fVHigh" onclick="setFreqBand('vhf-high')" title="VHF High: 136‚Äì174 MHz">VHF Hi</button>
          <button class="freq-opt" id="fULow"  onclick="setFreqBand('uhf-low')"  title="UHF Low: 400‚Äì512 MHz">UHF Lo</button>
          <button class="freq-opt" id="fUHigh" onclick="setFreqBand('uhf-high')" title="UHF High: 700‚Äì900 MHz">UHF Hi</button>
        </div>
        <p class="info-note" id="freqDesc">VHF High (136‚Äì174 MHz) ¬∑ Œª‚âà1.8 m</p>
      </div>

      <!-- Results -->
      <div class="section" id="resultsSection" style="display:none;">
        <div class="section-title">Results</div>
        <div id="losCard" class="los-card los-idle">
          <div class="los-icon" id="losIcon">‚Äî</div>
          <div class="los-text">
            <h3 id="losTitle">Calculating...</h3>
            <p id="losDesc">Running elevation analysis</p>
          </div>
        </div>
        <!-- Link quality meter -->
        <div class="link-meter" id="linkMeter" style="display:none;">
          <div class="link-meter-label">Link Quality Estimate</div>
          <div class="link-meter-track">
            <div class="link-meter-fill" id="linkMeterFill" style="width:0%;background:#69ff47;"></div>
          </div>
          <div class="link-diffraction" id="linkDiffInfo"></div>
        </div>
        <div class="stats-grid">
          <div class="stat-card"><div class="stat-label">Path Distance</div><div class="stat-value" id="statDist">‚Äî</div></div>
          <div class="stat-card"><div class="stat-label">Bearing</div><div class="stat-value" id="statBearing">‚Äî</div></div>
          <div class="stat-card"><div class="stat-label">Elev at A</div><div class="stat-value sv-a" id="statElevA">‚Äî</div></div>
          <div class="stat-card"><div class="stat-label">Elev at B</div><div class="stat-value sv-b" id="statElevB">‚Äî</div></div>
          <div class="stat-card"><div class="stat-label">Max Terrain</div><div class="stat-value" id="statMaxT">‚Äî</div></div>
          <div class="stat-card"><div class="stat-label">Earth Bulge</div><div class="stat-value" id="statBulge">‚Äî</div></div>
          <div class="stat-card full"><div class="stat-label">Min Clearance</div><div class="stat-value" id="statClear">‚Äî</div></div>
          <div class="stat-card full" id="diffrCard" style="display:none;"><div class="stat-label">Diffraction Loss (est.)</div><div class="stat-value" id="statDiffr">‚Äî</div></div>
        </div>

        <!-- Link Budget Result -->
        <div class="lbr-card" id="lbResultCard">
          <div class="lbr-title">üì° Link Budget Analysis</div>

          <!-- PRIMARY: corrected margin (shown when terrain corrections apply) -->
          <div id="lbrPrimaryBlock">
            <div class="lbr-margin-row">
              <span class="lbr-margin-val" id="lbrMarginVal">‚Äî</span>
              <span class="lbr-margin-label" id="lbrMarginLabel">dB estimated margin</span>
            </div>
            <div class="lbr-verdict" id="lbrVerdict">‚Äî</div>
          </div>

          <!-- Budget breakdown table -->
          <table class="lbr-table" id="lbrTable">
            <tbody id="lbrTableBody"></tbody>
          </table>

          <!-- Correction detail (shown when terrain corrections apply) -->
          <div class="lbr-correction-breakdown" id="lbrCorrectionBreakdown" style="display:none;"></div>

          <div class="lbr-hint" id="lbrHint"></div>
        </div>
      </div>

      <!-- Map / Google Key -->
      <div class="section">
        <div class="section-title">Google Maps (optional)</div>
        <p class="info-note" style="margin-bottom:8px;">
          Default satellite uses <strong style="color:var(--text)">Esri World Imagery</strong> ‚Äî free, no key.<br>
          Paste a Google Maps API key below to enable Google Satellite tiles.
        </p>
        <div class="gkey-row">
          <input type="text" id="googleApiKey" placeholder="AIza‚Ä¶ (Google Maps API key)">
          <button class="gkey-apply" onclick="applyGoogleKey()">Apply</button>
        </div>
        <div class="gkey-status" id="gkeyStatus"></div>
      </div>

      <!-- About -->
      <div class="section">
        <div class="section-title">About</div>
        <p class="info-note">
          Earth curvature (k=4/3) applied.<br>
          Diffraction: ITU-R P.526 knife-edge + Deygout 3-obstacle.<br>
          Terrain roughness: Œîh penalty (ITU-R P.1546 / Longley-Rice).<br>
          Path loss: Free Space (FSPL).<br>
          Buildings &amp; vegetation not included.<br>
          Elevation: Open-Meteo (SRTM 90m).<br>
          Geocoding: ArcGIS ‚Üí Photon ‚Üí Nominatim.<br>
          GPS: browser Geolocation API.
        </p>
      </div>

    </div><!-- /panel -->

    <!-- ‚ïê‚ïê MAP ‚ïê‚ïê -->
    <div id="map-wrap">
      <div id="map"></div>
      <div class="map-hint hidden" id="mapHint">Click to place site</div>
      <!-- Layer switcher -->
      <div class="layer-switcher" id="layerSwitcher">
        <button class="ls-btn" id="lsEsriSat" onclick="switchLayer('esri-sat')">
          <span class="ls-swatch" style="background:linear-gradient(135deg,#4a7c3f,#8b6914,#5a8a5a);"></span>
          Satellite
        </button>
        <button class="ls-btn" id="lsEsriHybrid" onclick="switchLayer('esri-hybrid')">
          <span class="ls-swatch" style="background:linear-gradient(135deg,#4a7c3f,#8b6914,#5a8a5a); box-shadow:inset 0 0 0 1px rgba(255,255,255,0.3);"></span>
          Hybrid
        </button>
        <button class="ls-btn" id="lsGoogleSat" onclick="switchLayer('google-sat')" title="Requires Google Maps API key (see panel)">
          <span class="ls-swatch" style="background:linear-gradient(135deg,#1a6b35,#4a9e4a);"></span>
          Google Sat
        </button>
        <button class="ls-btn" id="lsDark" onclick="switchLayer('dark')">
          <span class="ls-swatch" style="background:#161b22; border-color:rgba(255,255,255,0.3);"></span>
          Dark
        </button>
      </div>
    </div>

    <!-- ‚ïê‚ïê CHART ‚ïê‚ïê -->
    <div class="chart-wrap">
      <div class="chart-header">
        <span class="chart-title">Elevation Profile</span>
        <div class="chart-legend">
          <div class="leg"><div class="leg-sw" style="background:#4a5568;"></div> Terrain</div>
          <div class="leg"><div class="leg-sw" style="background:#00e5ff;"></div> Site A</div>
          <div class="leg"><div class="leg-sw" style="background:#69ff47;"></div> Site B</div>
          <div class="leg"><div class="leg-sw" style="background:#69ff47; opacity:.5;"></div> Clear</div>
          <div class="leg"><div class="leg-sw" style="background:#ff6b35;"></div> Blocked</div>
        </div>
      </div>
      <canvas id="elevChart"></canvas>
    </div>

  </div><!-- /main -->

  <!-- Mobile tab bar (hidden on desktop via CSS) -->
  <div class="mob-tabbar" id="mobTabbar">
    <button class="mob-tab active" id="mobTabMap" onclick="switchMobileTab('map')">
      <span class="mob-tab-icon">üó∫Ô∏è</span>
      Map
    </button>
    <button class="mob-tab" id="mobTabProfile" onclick="switchMobileTab('profile')">
      <span class="mob-tab-icon">üìà</span>
      RF Path
    </button>
    <button class="mob-tab" id="mobTabControls" onclick="switchMobileTab('controls')">
      <span class="mob-tab-icon">‚öôÔ∏è</span>
      Controls
    </button>
    <button class="mob-tab" id="mobTabResults" onclick="switchMobileTab('results')">
      <span class="mob-tab-icon">üìä</span>
      Results
    </button>
  </div>
</div><!-- /app-shell -->

<!-- Loading overlay -->
<div class="loading-overlay hidden" id="loadingOverlay">
  <div class="spinner"></div>
  <div id="loadingText">Fetching elevation data‚Ä¶</div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
<script>
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MOBILE LAYOUT ‚Äî inline styles beat all CSS specificity
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const MOB_BREAK = 768;
let _mobTab = 'controls';

function isMobile() { return window.innerWidth <= MOB_BREAK; }

function applyMobileLayout() {
  const header    = document.querySelector('.header');
  const main      = document.querySelector('.main');
  const panel     = document.querySelector('.panel');
  const mapWrap   = document.getElementById('map-wrap');
  const chartWrap = document.querySelector('.chart-wrap');
  const tabbar    = document.getElementById('mobTabbar');

  const TAB_H = 72;  // must match CSS .mob-tabbar height

  // Show tab bar first
  tabbar.style.display = 'flex';

  // Compact header
  header.style.padding = '8px 12px';
  header.style.gap     = '10px';
  const h1  = header.querySelector('h1');
  const hp  = header.querySelector('p');
  const ico = header.querySelector('.header-icon');
  const svg = ico ? ico.querySelector('svg') : null;
  if (h1)  h1.style.fontSize   = '13px';
  if (hp)  hp.style.fontSize   = '10px';
  if (ico) { ico.style.width = '34px'; ico.style.height = '34px'; }
  if (svg) { svg.setAttribute('width','22'); svg.setAttribute('height','22'); }

  // Measure header after compacting
  const headerH = header.offsetHeight;
  const mainH   = window.innerHeight - headerH - TAB_H;

  // .main: exact pixel height, relative positioning context
  main.style.cssText = `
    display: block !important;
    position: relative !important;
    height: ${mainH}px !important;
    overflow: hidden !important;
    grid-template-columns: unset !important;
    grid-template-rows: unset !important;
  `;

  // All three content panes ‚Äî map & panel fill full mainH, chart capped to landscape ratio
  const pane = 'position:absolute !important; top:0; left:0; right:0; bottom:0;';

  // Cap chart height so it stays landscape on portrait phones (screen-width √ó 0.68)
  // e.g. 390px wide ‚Üí 265px tall ‚Äî a ~1.47:1 ratio, readable and not distorted
  window._mobChartH = Math.round(Math.min(mainH, window.innerWidth * 0.68));

  mapWrap.style.cssText   = pane + ' display:block !important; overflow:hidden;';
  chartWrap.style.cssText = `position:absolute !important; top:0; left:0; right:0;
    height:${window._mobChartH}px !important;
    display:none !important; flex-direction:column; background:var(--surface);`;
  panel.style.cssText     = pane + ` display:none !important;
    overflow-y:auto !important; overflow-x:hidden !important;
    -webkit-overflow-scrolling:touch; background:var(--surface); z-index:5;`;

  // Compact chart header for RF Path tab
  const chartHeader = document.querySelector('.chart-header');
  const chartLegend = document.querySelector('.chart-legend');
  const chartTitle  = document.querySelector('.chart-title');
  if (chartHeader) chartHeader.style.cssText  = 'margin-bottom:6px; flex-shrink:0; padding:8px 10px 0; flex-wrap:wrap; row-gap:4px;';
  if (chartLegend) chartLegend.style.cssText  = 'font-size:10px; gap:8px; flex-wrap:wrap;';
  if (chartTitle)  chartTitle.style.cssText   = 'font-size:11px;';

  // Compact layer switcher ‚Üí horizontal row
  const ls = document.getElementById('layerSwitcher');
  if (ls) {
    ls.style.cssText = 'flex-direction:row; top:8px; right:6px; left:6px; gap:4px;';
    ls.querySelectorAll('.ls-btn').forEach(b => {
      b.style.cssText = 'flex:1; padding:5px 2px; font-size:10px; gap:3px; justify-content:center;';
    });
    ls.querySelectorAll('.ls-swatch').forEach(s => {
      s.style.cssText = 'width:10px; height:10px; border-radius:2px; flex-shrink:0;';
    });
  }

  _applyMobTab(_mobTab);
}

function _applyMobTab(tab) {
  const panel     = document.querySelector('.panel');
  const mapWrap   = document.getElementById('map-wrap');
  const chartWrap = document.querySelector('.chart-wrap');

  // Update active button
  document.querySelectorAll('.mob-tab').forEach(b => b.classList.remove('active'));
  const btnId = 'mobTab' + tab.charAt(0).toUpperCase() + tab.slice(1);
  const activeBtn = document.getElementById(btnId);
  if (activeBtn) activeBtn.classList.add('active');

  // Hide all panes first
  mapWrap.style.display   = 'none';
  chartWrap.style.display = 'none';
  panel.style.display     = 'none';

  if (tab === 'map') {
    mapWrap.style.display = 'block';
    setTimeout(() => {
      if (typeof map !== 'undefined' && map) {
        map.invalidateSize();
        // Re-fit to markers so mobile Map tab doesn't show world-zoom
        if (typeof markerA !== 'undefined' && markerA &&
            typeof markerB !== 'undefined' && markerB) {
          const llA = markerA.getLatLng();
          const llB = markerB.getLatLng();
          map.fitBounds(L.latLngBounds(llA, llB).pad(0.3));
        }
      }
    }, 80);

  } else if (tab === 'profile') {
    chartWrap.style.display = 'flex';
    // Double rAF ensures browser has completed layout before we measure canvas
    // Uses chartData (always set after analysis) not chartState (null if canvas was hidden)
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        if (typeof chartData !== 'undefined' && chartData) {
          const { dists, terrain, losLine, blocked, points } = chartData;
          drawChart(dists, terrain, losLine, blocked, points);
        }
      });
    });

  } else if (tab === 'controls') {
    panel.style.display = 'block';
    panel.scrollTop = 0;

  } else if (tab === 'results') {
    panel.style.display = 'block';
    setTimeout(() => {
      const rs = document.getElementById('resultsSection');
      if (rs) rs.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }, 60);
  }
}

function switchMobileTab(tab) {
  _mobTab = tab;
  if (isMobile()) _applyMobTab(tab);
}

function resetDesktopLayout() {
  const main     = document.querySelector('.main');
  const panel    = document.querySelector('.panel');
  const mapWrap  = document.getElementById('map-wrap');
  const chartWrap= document.querySelector('.chart-wrap');
  const tabbar   = document.getElementById('mobTabbar');
  const header   = document.querySelector('.header');
  const h1 = header ? header.querySelector('h1') : null;
  const hp = header ? header.querySelector('p')  : null;
  const ico= header ? header.querySelector('.header-icon') : null;
  const svg= ico   ? ico.querySelector('svg') : null;

  // Strip all inline styles we applied
  [main, panel, mapWrap, chartWrap].forEach(el => { if (el) el.removeAttribute('style'); });
  if (tabbar) tabbar.style.display = 'none';
  if (header) header.removeAttribute('style');
  if (h1)  h1.removeAttribute('style');
  if (hp)  hp.removeAttribute('style');
  if (ico) ico.removeAttribute('style');
  if (svg) { svg.setAttribute('width','32'); svg.setAttribute('height','32'); }
  const mapEl = document.getElementById('map');
  if (mapEl) mapEl.removeAttribute('style');
  // Restore chart header
  const ch  = document.querySelector('.chart-header');
  const cl  = document.querySelector('.chart-legend');
  const ct  = document.querySelector('.chart-title');
  if (ch) ch.removeAttribute('style');
  if (cl) cl.removeAttribute('style');
  if (ct) ct.removeAttribute('style');

  // Restore layer switcher
  const ls = document.getElementById('layerSwitcher');
  if (ls) {
    ls.removeAttribute('style');
    ls.querySelectorAll('.ls-btn').forEach(b => b.removeAttribute('style'));
    ls.querySelectorAll('.ls-swatch').forEach(s => s.removeAttribute('style'));
  }
  if (typeof map !== 'undefined' && map) setTimeout(() => map.invalidateSize(), 80);
  // Re-draw chart now that canvas is visible again at desktop dimensions
  if (typeof chartData !== 'undefined' && chartData) {
    const { dists, terrain, losLine, blocked, points } = chartData;
    requestAnimationFrame(() => { requestAnimationFrame(() => {
      drawChart(dists, terrain, losLine, blocked, points);
    }); });
  }
}

window.addEventListener('resize', () => {
  if (isMobile()) {
    applyMobileLayout();
  } else {
    resetDesktopLayout();
  }
});


</script>
<script>
'use strict';
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// CONSTANTS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const EARTH_R    = 6371000;  // metres
const K          = 4 / 3;   // effective Earth radius factor
const N_SAMPLES  = 99;       // gives 100 points total (0..99), fits Open-Meteo limit of 100

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// STATE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let map, markerA, markerB, pathLayer = null;
let mapClickMode    = 'off';
let ghostMarker     = null;
let crosshairMarker = null;   // live map marker synced to chart hover
let chartState      = null;   // populated after each analysis (requires visible canvas)
let chartData       = null;   // always set after analysis ‚Äî raw data for redraw
const geoCache      = {};

// Debounce guard: collapses rapid consecutive runAnalysis() calls into one
let _analysisTimer   = null;
let _analysisRunning = false;

// Elevation cache: keyed by "latA,lngA,latB,lngB" rounded to 4dp
// Same two endpoints = same 100 elevation samples; no need to re-fetch.
let _elevCache = {};  // key ‚Üí { elev: [...], dists: [...] }
let _elevCacheKey = null;  // key used for the last successful fetch

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MARKER ICONS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const mkIcon = (fill, glow) => L.divIcon({
  className: '',
  html: `<div style="width:14px;height:14px;background:${fill};border:2px solid #fff;border-radius:50%;box-shadow:0 0 8px ${glow};cursor:grab;"></div>`,
  iconSize: [14,14], iconAnchor: [7,7]
});
const mkGhost = (fill) => L.divIcon({
  className: '',
  html: `<div style="width:22px;height:22px;background:${fill};opacity:.45;border:2px dashed #fff;border-radius:50%;pointer-events:none;"></div>`,
  iconSize: [22,22], iconAnchor: [11,11]
});
const ICON_A = mkIcon('#00e5ff','#00e5ff');
const ICON_B = mkIcon('#69ff47','#69ff47');

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MAP INIT
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// LAYER DEFINITIONS & SWITCHER
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let activeBaseLayer = null;
let googleApiKey    = '';

const LAYERS = {
  'esri-sat': () => L.tileLayer(
    'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
    { attribution: 'Tiles &copy; Esri &mdash; Source: Esri, Maxar, Earthstar Geographics', maxZoom: 20 }
  ),
  'esri-hybrid': () => {
    // Esri satellite + Esri reference labels on top
    const sat = L.tileLayer(
      'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
      { attribution: 'Tiles &copy; Esri', maxZoom: 20 }
    );
    const labels = L.tileLayer(
      'https://server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}',
      { attribution: '', maxZoom: 20, opacity: 0.9 }
    );
    return L.layerGroup([sat, labels]);
  },
  'google-sat': () => {
    if (!googleApiKey) return null;
    // Google Maps requires their JS API for proper legal use.
    // We use the Maps Static tile endpoint via a proxy-compatible URL.
    return L.tileLayer(
      `https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}`,
      { attribution: 'Map data &copy; Google', maxZoom: 21, subdomains: ['mt0','mt1','mt2','mt3'] }
    );
  },
  'dark': () => L.tileLayer(
    'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png',
    { attribution: '&copy; OpenStreetMap &copy; CARTO', subdomains: 'abcd', maxZoom: 19 }
  ),
};

function switchLayer(id) {
  if (id === 'google-sat' && !googleApiKey) {
    document.getElementById('gkeyStatus').textContent = '‚ö† Enter a Google Maps API key first.';
    document.getElementById('gkeyStatus').className   = 'gkey-status err';
    // Scroll panel to key field
    document.getElementById('googleApiKey').scrollIntoView({ behavior: 'smooth', block: 'center' });
    return;
  }

  const newLayer = LAYERS[id] ? LAYERS[id]() : null;
  if (!newLayer) return;

  if (activeBaseLayer) {
    if (activeBaseLayer.eachLayer) activeBaseLayer.eachLayer(l => map.removeLayer(l));
    else map.removeLayer(activeBaseLayer);
  }

  if (newLayer.eachLayer) newLayer.eachLayer(l => l.addTo(map));
  else newLayer.addTo(map);
  activeBaseLayer = newLayer;

  // Update button states
  document.querySelectorAll('.ls-btn').forEach(b => b.classList.remove('active'));
  const btn = document.getElementById('ls' + id.split('-').map(s=>s[0].toUpperCase()+s.slice(1)).join(''));
  if (btn) btn.classList.add('active');

  // Ensure markers, path, and crosshair stay on top of new tile layer
  if (pathLayer) {
    if (pathLayer.eachLayer) pathLayer.eachLayer(l => { if(l.bringToFront) l.bringToFront(); });
    else if (pathLayer.bringToFront) pathLayer.bringToFront();
  }
  [markerA, markerB, crosshairMarker].forEach(m => { if(m?.bringToFront) m.bringToFront(); });
}

function applyGoogleKey() {
  const key = document.getElementById('googleApiKey').value.trim();
  const statusEl = document.getElementById('gkeyStatus');
  if (!key) {
    statusEl.textContent = '‚ö† Please paste your API key.'; statusEl.className = 'gkey-status err'; return;
  }
  if (!key.startsWith('AIza')) {
    statusEl.textContent = '‚ö† Key should start with "AIza‚Ä¶"'; statusEl.className = 'gkey-status err'; return;
  }
  googleApiKey = key;
  statusEl.textContent = '‚úì Key saved ‚Äî switching to Google Satellite‚Ä¶'; statusEl.className = 'gkey-status ok';
  switchLayer('google-sat');
}

function initMap() {
  map = L.map('map', { zoomControl: true }).setView([39.8283, -98.5795], 4);

  // Default: Esri satellite (free, no key, great quality)
  switchLayer('esri-hybrid');

  const llA = [+v('latA'), +v('lngA')];
  const llB = [+v('latB'), +v('lngB')];

  markerA = L.marker(llA, { icon: ICON_A, draggable: true, title: 'Site A' }).addTo(map);
  markerB = L.marker(llB, { icon: ICON_B, draggable: true, title: 'Site B' }).addTo(map);

  markerA.on('dragend', () => { copyMarkerToInputs('a'); runAnalysis(); });
  markerB.on('dragend', () => { copyMarkerToInputs('b'); runAnalysis(); });

  map.on('click', e => {
    if (mapClickMode === 'off') return;
    setCoords(mapClickMode, e.latlng.lat, e.latlng.lng);
    syncMarkerFromInputs(mapClickMode);
    dropGhost();
    setMapMode('off');
    runAnalysis();
  });

  map.on('mousemove', e => {
    if (mapClickMode === 'off') return;
    const fill = mapClickMode === 'a' ? '#00e5ff' : '#69ff47';
    if (!ghostMarker) ghostMarker = L.marker(e.latlng, { icon: mkGhost(fill), interactive: false, zIndexOffset: -200 }).addTo(map);
    else ghostMarker.setLatLng(e.latlng);
  });

  map.on('mouseout', dropGhost);

  // ‚îÄ‚îÄ Auto-center on user location at first load ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // If geolocation is available and granted, move both markers to user's
  // location and zoom in. Silently falls back to US-center if denied/unavailable.
  if ('geolocation' in navigator) {
    navigator.geolocation.getCurrentPosition(
      pos => {
        const lat = pos.coords.latitude;
        const lng = pos.coords.longitude;
        // Place Site A at user's exact location
        document.getElementById('latA').value = lat.toFixed(5);
        document.getElementById('lngA').value = lng.toFixed(5);
        markerA.setLatLng([lat, lng]);
        // Place Site B slightly northeast as a default second point
        const latB = lat  + 0.05;
        const lngB = lng  + 0.05;
        document.getElementById('latB').value = latB.toFixed(5);
        document.getElementById('lngB').value = lngB.toFixed(5);
        markerB.setLatLng([latB, lngB]);
        map.fitBounds(L.latLngBounds([lat, lng], [latB, lngB]).pad(0.5));
        drawPlaceholderPath([lat, lng], [latB, lngB]);
      },
      _err => {
        // Denied or unavailable ‚Äî US-center defaults already set above
        drawPlaceholderPath(llA, llB);
      },
      { timeout: 5000, maximumAge: 60000 }
    );
  } else {
    drawPlaceholderPath(llA, llB);
  }
}

function dropGhost() {
  if (ghostMarker) { map.removeLayer(ghostMarker); ghostMarker = null; }
}

function copyMarkerToInputs(site) {
  const ll = site === 'a' ? markerA.getLatLng() : markerB.getLatLng();
  setCoords(site, ll.lat, ll.lng);
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MAP CLICK MODE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function setMapMode(mode) {
  mapClickMode = mode;
  const mapEl  = document.getElementById('map');
  const hint   = document.getElementById('mapHint');
  const escEl  = document.getElementById('escHint');

  // Reset all toggle states
  ['modeOff','modeA','modeB'].forEach(id => document.getElementById(id).className = 'mc-opt');
  ['mapBtnA','mapBtnB'].forEach(id => document.getElementById(id).classList.remove('active-a','active-b'));
  mapEl.className = '';
  hint.className  = 'map-hint hidden';
  escEl.textContent = '';

  if (mode === 'a') {
    document.getElementById('modeA').classList.add('sel-a');
    document.getElementById('mapBtnA').classList.add('active-a');
    mapEl.classList.add('clickmode-a');
    hint.textContent = 'üìç Click to place Site A';
    hint.className   = 'map-hint hint-a';
    escEl.textContent = 'Press Esc to cancel';
  } else if (mode === 'b') {
    document.getElementById('modeB').classList.add('sel-b');
    document.getElementById('mapBtnB').classList.add('active-b');
    mapEl.classList.add('clickmode-b');
    hint.textContent = 'üìç Click to place Site B';
    hint.className   = 'map-hint hint-b';
    escEl.textContent = 'Press Esc to cancel';
  } else {
    document.getElementById('modeOff').classList.add('sel-off');
    dropGhost();
  }
}

document.addEventListener('keydown', e => {
  if (e.key === 'Escape' && mapClickMode !== 'off') setMapMode('off');
});

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// COORDINATE HELPERS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const v   = id => document.getElementById(id).value;
const set = (id, val) => { document.getElementById(id).value = val; };

function setCoords(site, lat, lng) {
  const S = site.toUpperCase();
  set('lat'+S, (+lat).toFixed(5));
  set('lng'+S, (+lng).toFixed(5));
}

function getCoords(site) {
  const S = site.toUpperCase();
  return { lat: parseFloat(v('lat'+S)), lng: parseFloat(v('lng'+S)) };
}

function syncMarkerFromInputs(site) {
  const { lat, lng } = getCoords(site);
  if (isNaN(lat) || isNaN(lng)) return;
  (site === 'a' ? markerA : markerB).setLatLng([lat, lng]);
}

function syncAllMarkers() {
  syncMarkerFromInputs('a');
  syncMarkerFromInputs('b');
}

['latA','lngA','latB','lngB'].forEach(id => {
  document.getElementById(id).addEventListener('change', syncAllMarkers);
});

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ANTENNA HEIGHT SYNC
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
['A','B'].forEach(S => {
  const range = document.getElementById('heightRange'+S);
  const num   = document.getElementById('height'+S);
  const disp  = document.getElementById('heightVal'+S);
  range.addEventListener('input', () => { num.value = range.value; disp.textContent = range.value + ' ft'; });
  num.addEventListener('input',   () => { range.value = Math.min(500, Math.max(0, +num.value)); disp.textContent = num.value + ' ft'; });
});

// Helper: antenna height in METERS from ft input (used in analysis)
function getAntennaMeters(site) {
  const ft = parseFloat(document.getElementById('height'+site.toUpperCase()).value) || 0;
  return ft * 0.3048;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// GEOLOCATION  ‚Äî with Permissions API pre-check
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
async function useMyLocation(site) {
  const S   = site.toUpperCase();
  const btn = document.getElementById('gps'+S);

  if (!('geolocation' in navigator)) {
    setAddrStatus(site, '‚ö† Geolocation not supported by this browser.', 'err');
    return;
  }

  // ‚îÄ‚îÄ Pre-check permission state if Permissions API available ‚îÄ‚îÄ
  if ('permissions' in navigator) {
    try {
      const perm = await navigator.permissions.query({ name: 'geolocation' });
      if (perm.state === 'denied') {
        setAddrStatus(site,
          '‚ö† Location permission is blocked. To fix: click the üîí icon in the browser address bar ‚Üí Site settings ‚Üí Location ‚Üí Allow, then reload.',
          'err');
        return;
      }
      // state === 'prompt' or 'granted' ‚Äî proceed normally
    } catch(e) { /* Permissions API not fully supported ‚Äî proceed anyway */ }
  }

  btn.disabled = true;
  btn.textContent = '‚è≥ ‚Ä¶';
  setAddrStatus(site, 'Requesting position ‚Äî check for a browser prompt‚Ä¶', 'inf');

  const reset = () => { btn.disabled = false; btn.textContent = 'üéØ My Location'; };

  navigator.geolocation.getCurrentPosition(
    pos => {
      const { latitude: lat, longitude: lng, accuracy } = pos.coords;
      setCoords(site, lat, lng);
      syncMarkerFromInputs(site);
      map.setView([lat, lng], Math.max(map.getZoom(), 14));
      setAddrStatus(site, `‚úì Located ¬∑ ¬±${Math.round(accuracy)} m accuracy`, 'ok');
      reset();
      runAnalysis();
    },
    err => {
      const msgs = {
        1: 'Permission denied ‚Äî click the üîí in the address bar, set Location ‚Üí Allow, then reload.',
        2: 'Position unavailable ‚Äî your device may not have location hardware.',
        3: 'Request timed out ‚Äî try again or check that location services are enabled in Windows Settings ‚Üí Privacy ‚Üí Location.'
      };
      setAddrStatus(site, '‚ö† ' + (msgs[err.code] || 'Unknown location error (code '+err.code+')'), 'err');
      reset();
    },
    // Use lower accuracy first (faster), fallback gracefully
    { enableHighAccuracy: false, timeout: 10000, maximumAge: 120000 }
  );
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// GEOCODING  ‚Äî Multi-source cascade
//
//  1. ArcGIS World Geocoder ‚Äî best US street-level coverage, free, no key,
//                             proper CORS, returns a confidence score
//  2. Photon / Komoot       ‚Äî international, CORS-safe, OSM-based
//  3. Nominatim / OSM       ‚Äî last resort
//
//  Each source is tried in order; the first HIGH-CONFIDENCE result wins.
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// ‚îÄ‚îÄ Source 1: ArcGIS World Geocoder ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Free for basic use, no API key, excellent US + global coverage,
// returns a 0-100 match score ‚Äî we reject anything below 70 to avoid bad fuzzy matches
async function geocodeViaArcGIS(query) {
  const url = `https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer/findAddressCandidates`
            + `?SingleLine=${encodeURIComponent(query)}`
            + `&f=json&outFields=Match_addr,Addr_type&outSR=4326&maxLocations=3`;
  const resp = await fetch(url);
  if (!resp.ok) throw new Error('ArcGIS HTTP ' + resp.status);
  const json = await resp.json();
  if (!json.candidates || json.candidates.length === 0) return null;

  // Sort by score descending, pick best candidate above threshold
  const candidates = json.candidates.sort((a,b) => b.score - a.score);
  const best = candidates[0];
  console.debug(`ArcGIS best match: "${best.attributes?.Match_addr}" score=${best.score}`);

  if (best.score < 70) {
    console.warn('ArcGIS: best score', best.score, '< 70, skipping');
    return null;
  }
  return {
    lat:   best.location.y,
    lng:   best.location.x,
    label: best.attributes?.Match_addr || query,
    score: best.score
  };
}

// ‚îÄ‚îÄ Source 2: Photon (Komoot) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// International, CORS *, free, OSM-based ‚Äî good for cities/landmarks
async function geocodeViaPhoton(query) {
  const url = `https://photon.komoot.io/api/?q=${encodeURIComponent(query)}&limit=3&lang=en`;
  const resp = await fetch(url);
  if (!resp.ok) throw new Error('Photon HTTP ' + resp.status);
  const geojson = await resp.json();
  if (!geojson.features || geojson.features.length === 0) return null;

  // Prefer results that have a house number (more specific)
  const feats = geojson.features;
  const withNum = feats.find(f => f.properties.housenumber);
  const feat    = withNum || feats[0];
  const [lng, lat] = feat.geometry.coordinates;
  const p = feat.properties;

  // Build label ‚Äî include house number + street if present
  const addrPart = p.housenumber && p.street ? `${p.housenumber} ${p.street}` : (p.street || p.name || '');
  const parts = [addrPart, p.city || p.town || p.county, p.state, p.country].filter(Boolean);
  return { lat, lng, label: parts.slice(0, 4).join(', ') };
}

// ‚îÄ‚îÄ Source 3: Nominatim (OSM) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async function geocodeViaNominatim(query) {
  const url = `https://nominatim.openstreetmap.org/search`
            + `?format=json&limit=1&q=${encodeURIComponent(query)}&addressdetails=1`;
  const resp = await fetch(url, { headers: { 'Accept-Language': 'en' } });
  if (!resp.ok) throw new Error('Nominatim HTTP ' + resp.status);
  const data = await resp.json();
  if (!data.length) return null;
  const d = data[0];
  const a = d.address || {};
  const addrPart = a.house_number ? `${a.house_number} ${a.road||''}`.trim() : (a.road || d.display_name.split(',')[0]);
  const parts = [addrPart, a.city || a.town || a.village || a.county, a.state, a.country].filter(Boolean);
  return { lat: parseFloat(d.lat), lng: parseFloat(d.lon), label: parts.slice(0,3).join(', ') };
}

// ‚îÄ‚îÄ Main geocode entry point ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async function geocode(site) {
  const S     = site.toUpperCase();
  const query = document.getElementById('addr'+S).value.trim();
  if (!query) { setAddrStatus(site, 'Enter an address or place name first.', 'err'); return; }

  const key = query.toLowerCase();
  if (geoCache[key]) { applyGeocode(site, geoCache[key]); return; }

  setAddrStatus(site, 'üîç Searching‚Ä¶', 'inf');

  const errors  = [];
  const sources = [
    { name: 'ArcGIS',    fn: geocodeViaArcGIS },
    { name: 'Photon',    fn: geocodeViaPhoton },
    { name: 'Nominatim', fn: geocodeViaNominatim },
  ];

  for (const src of sources) {
    try {
      setAddrStatus(site, `üîç Trying ${src.name}‚Ä¶`, 'inf');
      const result = await src.fn(query);
      if (result) {
        result.label = result.label || query;
        geoCache[key] = result;
        applyGeocode(site, result);
        return;
      }
      errors.push(`${src.name}: no results`);
    } catch(err) {
      console.warn(`Geocode [${src.name}] failed:`, err.message);
      errors.push(`${src.name}: ${err.message}`);
    }
  }

  console.error('All geocode sources failed:', errors);
  setAddrStatus(site,
    '‚ö† Address not found in any source. Try: full address with city & state, or use "Pick on Map".',
    'err');
}

function applyGeocode(site, result, silent = false) {
  setCoords(site, result.lat, result.lng);
  syncMarkerFromInputs(site);
  setAddrStatus(site, '‚úì ' + result.label, 'ok');
  map.setView([result.lat, result.lng], Math.max(map.getZoom(), 13));
  if (!silent) runAnalysis();
}

// Geocode a site only if its address field has unconfirmed text.
// "Unconfirmed" means the field is non-empty AND the status line
// doesn't already start with "‚úì" (i.e. hasn't been resolved yet).
// Returns true if geocoding was needed (and succeeded), false otherwise.
async function geocodeIfPending(site) {
  const S       = site.toUpperCase();
  const query   = document.getElementById('addr'+S).value.trim();
  const status  = document.getElementById('addrStatus'+S).textContent;
  if (!query || status.startsWith('‚úì')) return false;  // nothing to do

  setAddrStatus(site, 'üîç Resolving address‚Ä¶', 'inf');

  const key = query.toLowerCase();
  if (geoCache[key]) {
    applyGeocode(site, geoCache[key], /*silent=*/true);
    return true;
  }

  const sources = [
    { name: 'ArcGIS',    fn: geocodeViaArcGIS },
    { name: 'Photon',    fn: geocodeViaPhoton },
    { name: 'Nominatim', fn: geocodeViaNominatim },
  ];
  for (const src of sources) {
    try {
      const result = await src.fn(query);
      if (result) {
        result.label = result.label || query;
        geoCache[key] = result;
        applyGeocode(site, result, /*silent=*/true);
        return true;
      }
    } catch(e) { console.warn(`geocodeIfPending [${src.name}]:`, e.message); }
  }

  setAddrStatus(site, '‚ö† Could not resolve address ‚Äî check spelling or use "Pick on Map"', 'err');
  return false;
}

function setAddrStatus(site, msg, cls) {
  const el = document.getElementById('addrStatus' + site.toUpperCase());
  el.textContent = msg;
  el.className   = 'addr-status ' + cls;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// UNIT HELPERS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const M_TO_FT   = 3.28084;
const M_TO_MI   = 0.000621371;
const FT_TO_M   = 0.3048;

// Format meters ‚Üí "492 ft (150m)"  [panel display, both units]
function fmtFtM(meters) {
  const ft = Math.round(meters * M_TO_FT);
  const m  = Math.round(meters);
  return `${ft.toLocaleString()} ft (${m}m)`;
}
// Format meters ‚Üí "492 ft"  [chart-only, ft no suffix]
function fmtFt(meters) {
  return Math.round(meters * M_TO_FT).toLocaleString() + ' ft';
}
// Format meters distance ‚Üí "3.2 mi" or "528 ft"  [chart + panel distance]
function fmtDist(meters, milesOnly) {
  const mi = meters * M_TO_MI;
  if (milesOnly) return mi >= 0.1 ? mi.toFixed(2)+' mi' : Math.round(meters*M_TO_FT)+' ft';
  if (mi >= 0.1) return mi.toFixed(2)+' mi ('+( meters>=1000?(meters/1000).toFixed(1)+'km':Math.round(meters)+'m' )+')';
  return Math.round(meters*M_TO_FT)+' ft ('+Math.round(meters)+'m)';
}
// Clearance: signed, panel format
function fmtClearFtM(meters) {
  const ft = Math.round(meters * M_TO_FT);
  const m  = Math.round(meters);
  const sign = meters >= 0 ? '+' : '';
  return `${sign}${ft.toLocaleString()} ft (${sign}${m}m)`;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// FREQUENCY BAND STATE & DIFFRACTION MODEL
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//
//  RF beyond-LOS model based on ITU-R P.526 knife-edge diffraction.
//
//  For a single dominant obstacle, the Fresnel-Kirchhoff diffraction
//  parameter ŒΩ is:
//    ŒΩ = h_obs ¬∑ ‚àö(2(d1+d2) / (Œª¬∑d1¬∑d2))
//  where h_obs is the height of terrain ABOVE the LOS ray (positive when
//  blocked), d1/d2 are distances from each endpoint to the obstacle, and
//  Œª is wavelength in metres.
//
//  Diffraction loss J(ŒΩ) per ITU-R P.526-15 approx:
//    ŒΩ ‚â§ -0.78  ‚Üí J ‚âà 0 dB  (full Fresnel clearance)
//    -0.78‚Äì0    ‚Üí J ‚âà small (partial intrusion)
//    0‚Äì2.4      ‚Üí moderate loss
//    > 2.4      ‚Üí J ‚âà 20¬∑log10(0.225/ŒΩ)
//
//  Link quality grades (all bands assume a typical 150 dB budget for
//  portable VHF/UHF radios; adjust for fixed links):
//    Excellent  : LOS clear + ‚â•60% Fresnel clearance   ‚Üí 0 dB loss
//    Good       : LOS clear or ŒΩ ‚â§ 0.5                  ‚Üí 0‚Äì5 dB
//    Fair       : 0.5 < ŒΩ ‚â§ 1.5  (‚âà5‚Äì15 dB loss)      ‚Üí marginal
//    Poor       : 1.5 < ŒΩ ‚â§ 2.5  (‚âà15‚Äì25 dB loss)     ‚Üí very marginal
//    Unlikely   : ŒΩ > 2.5         (> 25 dB loss)        ‚Üí near-zero
//
//  VHF diffracts better than UHF because Œª is longer ‚Üí F1 is larger ‚Üí
//  same obstacle height yields a lower ŒΩ ‚Üí less diffraction loss.
//
const FREQ_BANDS = {
  'vhf-low':  { label:'VHF Low',  range:'30‚Äì88 MHz',   freqMHz: 60,  lambda: 300/60  },  // Œª=5.0m
  'vhf-high': { label:'VHF High', range:'136‚Äì174 MHz', freqMHz: 155, lambda: 300/155 },  // Œª=1.94m
  'uhf-low':  { label:'UHF Low',  range:'400‚Äì512 MHz', freqMHz: 450, lambda: 300/450 },  // Œª=0.67m
  'uhf-high': { label:'UHF High', range:'700‚Äì900 MHz', freqMHz: 800, lambda: 300/800 },  // Œª=0.375m
};
let currentBand = 'vhf-high';

function setFreqBand(band) {
  currentBand = band;
  document.querySelectorAll('.freq-opt').forEach(b => b.classList.remove('freq-sel'));
  const map_id = { 'vhf-low':'fVLow','vhf-high':'fVHigh','uhf-low':'fULow','uhf-high':'fUHigh' };
  document.getElementById(map_id[band]).classList.add('freq-sel');
  const fb = FREQ_BANDS[band];
  document.getElementById('freqDesc').textContent = `${fb.label} (${fb.range}) ¬∑ Œª‚âà${fb.lambda.toFixed(2)} m`;
  // Re-run if we already have results
  if (document.getElementById('resultsSection').style.display !== 'none') runAnalysis();
}

// Knife-edge diffraction loss J(ŒΩ) per ITU-R P.526 approximation
function knifeedgeLoss(nu) {
  if (nu <= -0.78) return 0;
  if (nu <= 0)     return 20 * Math.log10(0.5 - 0.62 * nu);
  if (nu <= 1)     return 20 * Math.log10(0.5 * Math.exp(-0.95 * nu));
  if (nu <= 2.4)   return 20 * Math.log10(0.4 - Math.sqrt(0.1184 - (0.38 - 0.1*nu)**2));
  return 20 * Math.log10(0.225 / nu);
}

// Compute worst-case ŒΩ across the path, find the dominant obstacle
function computeDiffraction(dists, terrain, losLine, D, lambda) {
  let worstNu = -Infinity, worstIdx = 0;
  for (let i = 1; i < dists.length - 1; i++) {
    const h_obs = terrain[i] - losLine[i]; // positive when terrain above LOS
    if (h_obs <= 0) continue;              // not an obstacle at this point
    const d1 = dists[i];
    const d2 = D - dists[i];
    if (d1 <= 0 || d2 <= 0) continue;
    const nu = h_obs * Math.sqrt(2 * (d1 + d2) / (lambda * d1 * d2));
    if (nu > worstNu) { worstNu = nu; worstIdx = i; }
  }
  if (worstNu === -Infinity) worstNu = -2; // fully clear
  const lossDb = knifeedgeLoss(worstNu);
  return { nu: worstNu, lossDb, obstacleIdx: worstIdx };
}


// ‚îÄ‚îÄ Deygout 3-obstacle diffraction (ITU-R P.526-15 ¬ß4.2) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
//
// Standard "3-knife-edge" Deygout method:
//   1. Find the dominant obstacle on the full path (highest ŒΩ).
//   2. Find the dominant sub-obstacle on the left sub-path  (A ‚Üí main peak).
//   3. Find the dominant sub-obstacle on the right sub-path (main peak ‚Üí B).
//   4. Sum all three individual knife-edge losses.
//
// Models multiple ridge crossings ‚Äî each contributing independently.
// Returns totalLossDb (positive), extraLossDb over single KE, nPeaks found.

function _findPeak(terrain, losLine, dists, lambda) {
  let bestNu = -99, bestIdx = -1;
  for (let i = 1; i < terrain.length - 1; i++) {
    const h = terrain[i] - losLine[i];
    if (h <= 0) continue;
    const d1 = dists[i] - dists[0];
    const d2 = dists[dists.length-1] - dists[i];
    if (d1 <= 0 || d2 <= 0) continue;
    const nu = h * Math.sqrt(2*(d1+d2) / (lambda*d1*d2));
    if (nu > bestNu) { bestNu = nu; bestIdx = i; }
  }
  return (bestIdx >= 0 && bestNu > -0.78) ? { idx: bestIdx, nu: bestNu } : null;
}

function computeDeygout(dists, terrain, losLine, D, lambda) {
  const main = _findPeak(terrain, losLine, dists, lambda);
  if (!main) return { totalLossDb: 0, extraLossDb: 0, nPeaks: 0, nuLeft: null, nuRight: null };

  // knifeedgeLoss returns negative (convention); flip to get positive loss dB
  const keLoss = nu => Math.max(0, -knifeedgeLoss(nu));
  const mainLoss = keLoss(main.nu);

  // Left sub-path A ‚Üí main peak; sub-LOS from losLine[0] to terrain[main.idx]
  let leftLoss = 0, nuLeft = null;
  if (main.idx > 1) {
    const lt = terrain.slice(0, main.idx + 1);
    const ld = dists.slice(0, main.idx + 1);
    const peakH = terrain[main.idx];
    const ll = ld.map((d,i) => losLine[0] + (peakH - losLine[0]) * (ld[i]-ld[0]) / (ld[ld.length-1]-ld[0]));
    const lp = _findPeak(lt, ll, ld, lambda);
    if (lp) { leftLoss = keLoss(lp.nu); nuLeft = lp.nu; }
  }

  // Right sub-path main peak ‚Üí B; sub-LOS from terrain[main.idx] to losLine[end]
  let rightLoss = 0, nuRight = null;
  if (main.idx < terrain.length - 2) {
    const rt = terrain.slice(main.idx);
    const rd = dists.slice(main.idx);
    const peakH = terrain[main.idx];
    const rl = rd.map((d,i) => peakH + (losLine[losLine.length-1] - peakH) * (rd[i]-rd[0]) / (rd[rd.length-1]-rd[0]));
    const rp = _findPeak(rt, rl, rd, lambda);
    if (rp) { rightLoss = keLoss(rp.nu); nuRight = rp.nu; }
  }

  const totalLossDb = mainLoss + leftLoss + rightLoss;
  const extraLossDb = leftLoss + rightLoss;
  const nPeaks = 1 + (nuLeft !== null ? 1 : 0) + (nuRight !== null ? 1 : 0);
  return { totalLossDb, extraLossDb, nPeaks, nuLeft, nuRight };
}

// ‚îÄ‚îÄ Œîh Terrain Roughness Penalty (ITU-R P.1546 / Longley-Rice) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
//
// Œîh = interdecile height variation = P90(elev) ‚àí P10(elev) along path.
// Models background scatter from rolling hills, trees, rocks ‚Äî the continuous
// loss that single-peak diffraction misses between the main obstacles.
//
// Calibrated against Longley-Rice for VHF/UHF terrestrial paths:
//   Flat/gentle (Œîh<10m)  ‚Üí 0 dB
//   Rolling hills (Œîh~50m) ‚Üí ~3 dB
//   Significant (Œîh~150m)  ‚Üí ~7 dB
//   Mountainous (Œîh~300m)  ‚Üí ~11 dB
// Capped at 14 dB to avoid double-counting with Deygout corrections.

function computeTerrainRoughness(elevations, distMeters, freqMHz) {
  if (!elevations || elevations.length < 10) return { lossDb: 0, deltaH: 0 };
  const sorted = [...elevations].sort((a,b) => a-b);
  const n   = sorted.length;
  const p10 = sorted[Math.floor(n * 0.10)];
  const p90 = sorted[Math.floor(n * 0.90)];
  const dh  = Math.max(0, p90 - p10);
  if (dh <= 10) return { lossDb: 0, deltaH: dh };
  const dKm        = distMeters / 1000;
  const distFactor = 1 + 0.3 * Math.log10(Math.max(dKm, 10) / 10);
  const freqFactor = Math.pow(freqMHz / 150, 0.1);
  const loss       = Math.min(14.0, 5.0 * Math.log10(dh / 10) * distFactor * freqFactor);
  return { lossDb: Math.max(0, loss), deltaH: dh };
}

// Map diffraction result to a link quality grade
function linkGrade(nu, minClearM, anyBlocked) {
  // F1 intrusion: fully clear = nu ‚â§ -0.78 (60% clearance rule)
  if (!anyBlocked && nu <= -0.78) return { grade:'excellent', pct:100, label:'EXCELLENT', icon:'‚úÖ', desc:'Full LOS ¬∑ first Fresnel zone clear' };
  if (!anyBlocked && nu <= 0)     return { grade:'good',      pct:85,  label:'GOOD',      icon:'üü¢', desc:'LOS clear ¬∑ minor Fresnel intrusion' };
  if (!anyBlocked && nu <= 0.5)   return { grade:'good',      pct:75,  label:'GOOD',      icon:'üü¢', desc:'LOS clear ¬∑ partial Fresnel zone blocked' };
  if (nu <= 0.5)                   return { grade:'fair',      pct:60,  label:'FAIR',      icon:'üü°', desc:'Marginal LOS ¬∑ expect reduced signal' };
  if (nu <= 1.5)                   return { grade:'fair',      pct:45,  label:'FAIR',      icon:'üü°', desc:'Diffraction path ¬∑ signal likely usable' };
  if (nu <= 2.5)                   return { grade:'poor',      pct:25,  label:'POOR',      icon:'üü†', desc:'Heavy diffraction ¬∑ marginal / intermittent' };
  return                                  { grade:'unlikely',  pct:8,   label:'UNLIKELY',  icon:'üî¥', desc:'Severe obstruction ¬∑ contact improbable' };
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MATH
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const toRad = d => d * Math.PI / 180;
const toDeg = r => r * 180 / Math.PI;

function haversine(lat1, lng1, lat2, lng2) {
  const dLat = toRad(lat2-lat1), dLng = toRad(lng2-lng1);
  const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLng/2)**2;
  return 2 * EARTH_R * Math.asin(Math.sqrt(a));
}

function bearing(lat1, lng1, lat2, lng2) {
  const dLng = toRad(lng2-lng1);
  const y = Math.sin(dLng)*Math.cos(toRad(lat2));
  const x = Math.cos(toRad(lat1))*Math.sin(toRad(lat2)) - Math.sin(toRad(lat1))*Math.cos(toRad(lat2))*Math.cos(dLng);
  return (toDeg(Math.atan2(y,x))+360)%360;
}

const lerp  = (a, b, t) => a + (b-a)*t;
const bulge = (d, D) => (d*(D-d)) / (2*K*EARTH_R);

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ELEVATION  ‚Äî Open-Meteo API (primary) + Open-Elevation fallback
//   ‚Ä¢ Open-Meteo: Free, no key, CORS-friendly, SRTM data, max 100 pts
//   ‚Ä¢ Open-Elevation: Free fallback if Open-Meteo is rate-limited
//   ‚Ä¢ Exponential backoff on 429 (Too Many Requests)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

async function _fetchOpenMeteo(points) {
  const lats = points.map(p => p[0].toFixed(5)).join(',');
  const lngs = points.map(p => p[1].toFixed(5)).join(',');
  const url  = `https://api.open-meteo.com/v1/elevation?latitude=${lats}&longitude=${lngs}`;

  // Quick check: 2 attempts only (0s, 1.5s) ‚Äî bail fast to fallback
  const delays = [0, 1500];
  for (let attempt = 0; attempt < delays.length; attempt++) {
    if (delays[attempt] > 0) {
      document.getElementById('loadingText').textContent =
        `Rate limited ‚Äî retrying‚Ä¶ (attempt ${attempt+1})`;
      await new Promise(r => setTimeout(r, delays[attempt]));
    }
    try {
      const resp = await fetch(url);
      if (resp.status === 429) {
        if (attempt === delays.length - 1) throw new Error('RATE_LIMITED');
        continue;
      }
      if (!resp.ok) throw new Error('Elevation API HTTP ' + resp.status);
      const json = await resp.json();
      if (!json.elevation) throw new Error('Elevation API: unexpected response');
      return json.elevation;
    } catch (e) {
      if (e.message === 'RATE_LIMITED') throw e;
      if (attempt === delays.length - 1) throw e;
    }
  }
}

async function _fetchOpenElevation(points) {
  // POST-based API ‚Äî avoids URL length limits and works with 100 points
  const locations = points.map(p => ({ latitude: +p[0].toFixed(5), longitude: +p[1].toFixed(5) }));
  const resp = await fetch('https://api.open-elevation.com/api/v1/lookup', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ locations })
  });
  if (!resp.ok) throw new Error('Open-Elevation HTTP ' + resp.status);
  const json = await resp.json();
  if (!json.results || json.results.length !== points.length) throw new Error('Open-Elevation: unexpected response');
  return json.results.map(r => r.elevation);
}

async function fetchElevations(points) {
  // Try primary (Open-Meteo) first
  try {
    return await _fetchOpenMeteo(points);
  } catch (primaryErr) {
    console.warn('Open-Meteo failed, trying fallback:', primaryErr.message);
    document.getElementById('loadingText').textContent = 'Primary API unavailable ‚Äî trying fallback‚Ä¶';
  }
  // Fallback to Open-Elevation
  try {
    return await _fetchOpenElevation(points);
  } catch (fallbackErr) {
    console.error('Fallback also failed:', fallbackErr.message);
    throw new Error(
      'Both elevation APIs failed.\n'
      + 'Primary (Open-Meteo): rate limited or unreachable.\n'
      + 'Fallback (Open-Elevation): ' + fallbackErr.message + '.\n\n'
      + 'Wait 30‚Äì60 seconds and try again, or check your connection.'
    );
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MAP PATH
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function clearPath() {
  if (!pathLayer) return;
  if (pathLayer.eachLayer) pathLayer.eachLayer(l => map.removeLayer(l));
  else map.removeLayer(pathLayer);
  pathLayer = null;
}

function drawPlaceholderPath(llA, llB) {
  clearPath();
  pathLayer = L.polyline([llA, llB], { color:'#4a5568', weight:2, opacity:.6, dashArray:'6 4' }).addTo(map);
}

function drawSegmentedPath(points, blocked) {
  clearPath();
  const layers = [];
  if (points.length < 2) return;

  let start = 0, curB = blocked[0];
  for (let i = 1; i <= points.length - 1; i++) {
    const b = blocked[Math.min(i, blocked.length-1)];
    const isLast = i === points.length - 1;
    if (b !== curB || isLast) {
      const seg = points.slice(start, isLast ? i+1 : i);
      if (seg.length >= 2) {
        layers.push(L.polyline(seg, { color: curB ? '#ff6b35' : '#69ff47', weight: 3, opacity: .9 }));
      }
      start = i;
      curB  = b;
    }
  }

  if (!layers.length) {
    layers.push(L.polyline(points, { color: blocked.some(Boolean) ? '#ff6b35' : '#69ff47', weight: 3 }));
  }

  pathLayer = L.layerGroup(layers).addTo(map);
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ELEVATION CHART
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Chart padding ‚Äî scales up on mobile to fit larger axis labels
function getChartPad() {
  return isMobile()
    ? { l:72, r:18, t:16, b:38 }   // mobile: 13px font needs more room
    : { l:52, r:16, t:14, b:28 };  // desktop: 9px font
}
// Legacy alias so existing code using CHART_PAD directly still works
const CHART_PAD = { l:52, r:16, t:14, b:28 };  // desktop fallback

function drawChartBase(ctx, W, H, dists, terrain, losLine, blocked) {
  const pad  = getChartPad();
  const mob  = isMobile();
  const axisFont = `${mob ? 12 : 9}px "Share Tech Mono",monospace`;
  const pW = W-pad.l-pad.r, pH = H-pad.t-pad.b;
  if (pW <= 0 || pH <= 0) return;

  const maxD = dists[dists.length-1];
  const allE = [...terrain, ...losLine];
  const minE = Math.min(...allE)-5, maxE = Math.max(...allE)+20, rng = maxE-minE;

  const xS = d => pad.l + (d/maxD)*pW;
  const yS = e => pad.t + pH - ((e-minE)/rng)*pH;

  // Grid
  ctx.strokeStyle = 'rgba(255,255,255,0.04)'; ctx.lineWidth = 1;
  for (let i=0; i<=4; i++) {
    const y = pad.t + (i/4)*pH;
    ctx.beginPath(); ctx.moveTo(pad.l,y); ctx.lineTo(pad.l+pW,y); ctx.stroke();
    ctx.fillStyle='rgba(125,133,144,0.8)'; ctx.font=axisFont;
    ctx.textAlign='right';
    ctx.fillText(Math.round((maxE-(i/4)*rng)*M_TO_FT).toLocaleString()+'ft', pad.l-4, y+3);
  }
  for (let i=0; i<=5; i++) {
    const x = pad.l + (i/5)*pW;
    ctx.beginPath(); ctx.moveTo(x,pad.t); ctx.lineTo(x,pad.t+pH); ctx.stroke();
    ctx.fillStyle='rgba(125,133,144,0.8)'; ctx.font=axisFont;
    ctx.textAlign='center';
    const d = (i/5)*maxD;
    const dMi = d * M_TO_MI;
    ctx.fillText(dMi>=0.1?dMi.toFixed(2)+'mi':Math.round(d*M_TO_FT)+'ft', x, pad.t+pH+(mob?20:14));
  }

  // Terrain fill
  ctx.beginPath();
  ctx.moveTo(xS(dists[0]), yS(terrain[0]));
  for (let i=1; i<dists.length; i++) ctx.lineTo(xS(dists[i]), yS(terrain[i]));
  ctx.lineTo(xS(dists[dists.length-1]), pad.t+pH);
  ctx.lineTo(xS(dists[0]),              pad.t+pH);
  ctx.closePath();
  const g = ctx.createLinearGradient(0,pad.t,0,pad.t+pH);
  g.addColorStop(0,'rgba(74,85,104,.7)'); g.addColorStop(1,'rgba(74,85,104,.1)');
  ctx.fillStyle=g; ctx.fill();

  // Terrain line
  ctx.beginPath();
  ctx.moveTo(xS(dists[0]), yS(terrain[0]));
  for (let i=1; i<dists.length; i++) ctx.lineTo(xS(dists[i]), yS(terrain[i]));
  ctx.strokeStyle='#718096'; ctx.lineWidth=1.5; ctx.setLineDash([]); ctx.stroke();

  // LOS segmented
  let s0=0, pb=blocked[0];
  const flush = end => {
    if (end <= s0) return;
    ctx.beginPath();
    ctx.moveTo(xS(dists[s0]), yS(losLine[s0]));
    for (let i=s0+1; i<=end; i++) ctx.lineTo(xS(dists[i]), yS(losLine[i]));
    ctx.strokeStyle = pb ? '#ff6b35' : '#69ff47';
    ctx.lineWidth=2.5; ctx.setLineDash([6,3]); ctx.stroke(); ctx.setLineDash([]);
  };
  for (let i=1; i<blocked.length; i++) {
    if (blocked[i] !== pb) { flush(i-1); s0=i-1; pb=blocked[i]; }
  }
  flush(blocked.length-1);

  // Endpoint dots
  [[0,'#00e5ff','A','left'],[dists.length-1,'#69ff47','B','right']].forEach(([idx,fill,lbl,align]) => {
    const x=xS(dists[idx]), y=yS(losLine[idx]);
    ctx.beginPath(); ctx.arc(x,y,5,0,Math.PI*2); ctx.fillStyle=fill; ctx.fill();
    ctx.fillStyle=fill; ctx.font='bold 11px Barlow,sans-serif'; ctx.textAlign=align;
    ctx.fillText(lbl, align==='left'?x+9:x-9, y+4);
  });

  // Border
  ctx.strokeStyle='rgba(255,255,255,0.06)'; ctx.lineWidth=1; ctx.setLineDash([]);
  ctx.strokeRect(pad.l,pad.t,pW,pH);
}

function drawChart(dists, terrain, losLine, blocked, points) {
  const canvas = document.getElementById('elevChart');
  canvas.width  = canvas.offsetWidth;
  canvas.height = canvas.offsetHeight;
  const ctx = canvas.getContext('2d', { willReadFrequently: true });
  const W = canvas.width, H = canvas.height;
  if (!W || !H) return;
  ctx.clearRect(0, 0, W, H);

  drawChartBase(ctx, W, H, dists, terrain, losLine, blocked);

  // Save base image for fast crosshair overlay restore
  const allE = [...terrain, ...losLine];
  const minE = Math.min(...allE)-5, maxE = Math.max(...allE)+20;

  chartState = {
    dists, terrain, losLine, blocked, points,
    maxD: dists[dists.length-1],
    minE, maxE, rng: maxE-minE,
    W, H,
    baseImage: ctx.getImageData(0, 0, W, H)
  };
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// CHART INTERACTIVITY ‚Äî crosshair + live map marker
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function initChartInteractivity() {
  const canvas = document.getElementById('elevChart');

  canvas.addEventListener('mousemove', e => {
    if (!chartState) return;
    const rect = canvas.getBoundingClientRect();
    const mouseX = (e.clientX - rect.left) * (canvas.width  / rect.width);
    const mouseY = (e.clientY - rect.top)  * (canvas.height / rect.height);

    const { dists, terrain, losLine, blocked, points,
            maxD, minE, rng, W, H, baseImage } = chartState;
    const pad = getChartPad();
    const pW = W-pad.l-pad.r, pH = H-pad.t-pad.b;

    // Clamp to plot area
    if (mouseX < pad.l || mouseX > pad.l+pW || mouseY < pad.t || mouseY > pad.t+pH) {
      clearCrosshair();
      return;
    }

    // Find closest sample index by x position
    const fraction = (mouseX - pad.l) / pW;
    const rawIdx   = fraction * (dists.length - 1);
    const idx      = Math.max(0, Math.min(dists.length-1, Math.round(rawIdx)));

    const xS = d => pad.l + (d/maxD)*pW;
    const yS = e_ => pad.t + pH - ((e_-minE)/rng)*pH;

    const dist     = dists[idx];
    const terrElev = terrain[idx];
    const losElev  = losLine[idx];
    const clearance= losElev - terrElev;
    const isBlocked= blocked[idx];
    const xPx      = xS(dist);
    const accentCol= isBlocked ? '#ff6b35' : '#69ff47';

    // ‚îÄ‚îÄ Restore base image ‚îÄ‚îÄ
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    ctx.putImageData(baseImage, 0, 0);

    // ‚îÄ‚îÄ Vertical crosshair line ‚îÄ‚îÄ
    ctx.save();
    ctx.strokeStyle = accentCol;
    ctx.lineWidth   = 1.5;
    ctx.setLineDash([4, 3]);
    ctx.globalAlpha = 0.7;
    ctx.beginPath();
    ctx.moveTo(xPx, pad.t);
    ctx.lineTo(xPx, pad.t+pH);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.globalAlpha = 1;

    // ‚îÄ‚îÄ Dot at terrain ‚îÄ‚îÄ
    ctx.beginPath();
    ctx.arc(xPx, yS(terrElev), 4, 0, Math.PI*2);
    ctx.fillStyle = '#718096'; ctx.fill();
    ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.stroke();

    // ‚îÄ‚îÄ Dot at LOS ray ‚îÄ‚îÄ
    ctx.beginPath();
    ctx.arc(xPx, yS(losElev), 4, 0, Math.PI*2);
    ctx.fillStyle = accentCol; ctx.fill();
    ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.stroke();

    // ‚îÄ‚îÄ Tooltip box ‚Äî scales up on mobile ‚îÄ‚îÄ
    const distMi    = dist * M_TO_MI;
    const distLabel = distMi >= 0.1 ? distMi.toFixed(2)+' mi' : Math.round(dist*M_TO_FT)+' ft';
    const clearFt   = Math.round(clearance * M_TO_FT);
    const clearSign = clearance >= 0 ? '+' : '';
    const lines = [
      { label: 'Distance',  val: distLabel },
      { label: 'Terrain',   val: fmtFt(terrElev) },
      { label: 'LOS Ray',   val: fmtFt(losElev) },
      { label: 'Clearance', val: clearSign+clearFt+' ft', col: isBlocked ? '#ff6b35' : '#69ff47' },
      { label: '',          val: isBlocked ? 'BLOCKED' : 'CLEAR', col: isBlocked ? '#ff6b35' : '#69ff47' },
    ];

    const mob    = isMobile();
    const ttFont = mob ? 13 : 10;  // px
    const boxW   = mob ? Math.min(W - 20, 210) : 148;
    const lineH  = mob ? 22 : 16;
    const boxPad = mob ? 14 : 10;
    const boxH   = lines.length * lineH + boxPad * 2;

    // Position: prefer right of crosshair, flip left if needed, always within canvas
    let bx = xPx + (mob ? 14 : 10);
    if (bx + boxW > W - 4) bx = xPx - boxW - (mob ? 14 : 10);
    bx = Math.max(4, bx);
    const by = Math.max(pad.t + 4, Math.min(pad.t + pH - boxH - 4, pad.t + 6));

    ctx.fillStyle   = 'rgba(13,17,23,0.94)';
    ctx.strokeStyle = accentCol;
    ctx.lineWidth   = mob ? 1.5 : 1;
    ctx.beginPath();
    ctx.roundRect(bx, by, boxW, boxH, mob ? 8 : 5);
    ctx.fill(); ctx.stroke();

    ctx.font = `${mob ? 'bold ' : ''}${ttFont}px "Share Tech Mono",monospace`;
    lines.forEach((ln, i) => {
      const y = by + boxPad + i * lineH + (mob ? 13 : 10);
      ctx.fillStyle = 'rgba(160,170,160,0.9)';
      ctx.textAlign = 'left';
      ctx.fillText(ln.label, bx + (mob ? 10 : 8), y);
      ctx.fillStyle = ln.col || '#e6edf3';
      ctx.textAlign = 'right';
      ctx.fillText(ln.val, bx + boxW - (mob ? 10 : 8), y);
    });
    ctx.restore();

    // ‚îÄ‚îÄ Live marker on Leaflet map ‚îÄ‚îÄ
    const ll = points[idx];
    if (ll) {
      const markerColor  = isBlocked ? '#ff6b35' : '#69ff47';
      const markerGlow   = isBlocked ? '#ff6b35' : '#69ff47';
      const icon = L.divIcon({
        className: '',
        html: `<div style="
          width:16px;height:16px;
          background:${markerColor};
          border:2px solid #fff;
          border-radius:50%;
          box-shadow:0 0 10px 3px ${markerGlow};
          pointer-events:none;
        "></div>`,
        iconSize: [16,16], iconAnchor: [8,8]
      });
      if (!crosshairMarker) {
        crosshairMarker = L.marker(ll, { icon, interactive: false, zIndexOffset: 500 }).addTo(map);
      } else {
        crosshairMarker.setLatLng(ll);
        crosshairMarker.setIcon(icon);
      }
    }
  });

  canvas.addEventListener('mouseleave', clearCrosshair);

  // ‚îÄ‚îÄ Touch support for mobile profile tab ‚îÄ‚îÄ
  function handleTouch(e) {
    if (!chartState) return;
    e.preventDefault();
    const touch = e.touches[0] || e.changedTouches[0];
    if (!touch) return;
    // Synthesize a mousemove-style event
    const rect = canvas.getBoundingClientRect();
    const fakeEvent = {
      clientX: touch.clientX,
      clientY: touch.clientY
    };
    // Reuse the mousemove handler logic inline
    const mouseX = (fakeEvent.clientX - rect.left) * (canvas.width  / rect.width);
    const mouseY = (fakeEvent.clientY - rect.top)  * (canvas.height / rect.height);
    const { dists, terrain, losLine, blocked, points,
            maxD, minE, rng, W, H, baseImage } = chartState;
    const pad = getChartPad();
    const pW = W-pad.l-pad.r, pH = H-pad.t-pad.b;
    if (mouseX < pad.l || mouseX > pad.l+pW || mouseY < pad.t || mouseY > pad.t+pH) {
      clearCrosshair(); return;
    }
    const fraction = (mouseX - pad.l) / pW;
    const idx = Math.max(0, Math.min(dists.length-1, Math.round(fraction*(dists.length-1))));
    const xS = d => pad.l + (d/maxD)*pW;
    const yS = e_ => pad.t + pH - ((e_-minE)/rng)*pH;
    const dist      = dists[idx];
    const terrElev  = terrain[idx];
    const losElev   = losLine[idx];
    const clearance = losElev - terrElev;
    const isBlocked = blocked[idx];
    const xPx       = xS(dist);
    const accentCol = isBlocked ? '#ff6b35' : '#69ff47';
    const ctx2 = canvas.getContext('2d', { willReadFrequently: true });
    ctx2.putImageData(baseImage, 0, 0);
    ctx2.save();
    ctx2.strokeStyle = accentCol; ctx2.lineWidth = 2; ctx2.setLineDash([4,3]);
    ctx2.globalAlpha = 0.8;
    ctx2.beginPath(); ctx2.moveTo(xPx, pad.t); ctx2.lineTo(xPx, pad.t+pH); ctx2.stroke();
    ctx2.setLineDash([]); ctx2.globalAlpha = 1;
    ctx2.beginPath(); ctx2.arc(xPx, yS(terrElev), 5, 0, Math.PI*2);
    ctx2.fillStyle='#718096'; ctx2.fill(); ctx2.strokeStyle='#fff'; ctx2.lineWidth=1.5; ctx2.stroke();
    ctx2.beginPath(); ctx2.arc(xPx, yS(losElev), 5, 0, Math.PI*2);
    ctx2.fillStyle=accentCol; ctx2.fill(); ctx2.strokeStyle='#fff'; ctx2.lineWidth=1.5; ctx2.stroke();
    // Tooltip
    const distMi    = dist * M_TO_MI;
    const distLabel = distMi >= 0.1 ? distMi.toFixed(2)+' mi' : Math.round(dist*M_TO_FT)+' ft';
    const clearFt   = Math.round(clearance * M_TO_FT);
    const clearSign = clearance >= 0 ? '+' : '';
    const lines = [
      { label:'Distance',  val:distLabel },
      { label:'Terrain',   val:fmtFt(terrElev) },
      { label:'LOS Ray',   val:fmtFt(losElev) },
      { label:'Clearance', val:clearSign+clearFt+' ft', col:isBlocked?'#ff6b35':'#69ff47' },
      { label:'',          val:isBlocked?'BLOCKED':'CLEAR',  col:isBlocked?'#ff6b35':'#69ff47' },
    ];
    const boxW = Math.min(W - 20, 210), lineH = 22, boxPad = 14;
    const boxH = lines.length * lineH + boxPad * 2;
    let bx = xPx + 14;
    if (bx + boxW > W - 4) bx = xPx - boxW - 14;
    bx = Math.max(4, bx);
    const by = Math.max(pad.t + 4, pad.t + 6);
    ctx2.fillStyle='rgba(13,17,23,0.94)'; ctx2.strokeStyle=accentCol; ctx2.lineWidth=1.5;
    ctx2.beginPath(); ctx2.roundRect(bx, by, boxW, boxH, 8); ctx2.fill(); ctx2.stroke();
    ctx2.font='bold 13px "Share Tech Mono",monospace';
    lines.forEach((ln, i) => {
      const y = by + boxPad + i*lineH + 13;
      ctx2.fillStyle='rgba(160,170,160,0.9)'; ctx2.textAlign='left';
      ctx2.fillText(ln.label, bx+10, y);
      ctx2.fillStyle=ln.col||'#e6edf3'; ctx2.textAlign='right';
      ctx2.fillText(ln.val, bx+boxW-10, y);
    });
    ctx2.restore();
    // Map crosshair
    const ll = points[idx];
    if (ll && typeof map !== 'undefined' && map) {
      const icon = L.divIcon({ className:'',
        html:`<div style="width:16px;height:16px;background:${accentCol};border:2px solid #fff;border-radius:50%;box-shadow:0 0 10px 3px ${accentCol};pointer-events:none;"></div>`,
        iconSize:[16,16], iconAnchor:[8,8] });
      if (!crosshairMarker) crosshairMarker = L.marker(ll,{icon,interactive:false,zIndexOffset:500}).addTo(map);
      else { crosshairMarker.setLatLng(ll); crosshairMarker.setIcon(icon); }
    }
  }
  canvas.addEventListener('touchstart',  handleTouch, { passive: false });
  canvas.addEventListener('touchmove',   handleTouch, { passive: false });
  canvas.addEventListener('touchend',    clearCrosshair);
}

function clearCrosshair() {
  if (chartState?.baseImage) {
    const canvas = document.getElementById('elevChart');
    canvas.getContext('2d').putImageData(chartState.baseImage, 0, 0);
  }
  if (crosshairMarker) {
    map.removeLayer(crosshairMarker);
    crosshairMarker = null;
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MAIN ANALYSIS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// Public entry point ‚Äî debounced so rapid calls (geocode callbacks,
// drag events, band switch) collapse into a single elevation fetch.
function runAnalysis() {
  clearTimeout(_analysisTimer);
  _analysisTimer = setTimeout(_doAnalysis, 600);
}

async function _doAnalysis() {
  if (_analysisRunning) return;
  _analysisRunning = true;

  // ‚îÄ‚îÄ Pre-flight: geocode any address fields that were typed but not confirmed ‚îÄ‚îÄ
  // Run sequentially (not parallel) to avoid duplicate API calls and
  // to keep the second geocode from firing a re-entrant runAnalysis.
  await geocodeIfPending('a');
  await geocodeIfPending('b');

  const a = getCoords('a'), b = getCoords('b');
  if (isNaN(a.lat)||isNaN(a.lng)||isNaN(b.lat)||isNaN(b.lng)) {
    _analysisRunning = false; return;
  }

  const hA = getAntennaMeters('a');
  const hB = getAntennaMeters('b');

  syncAllMarkers();

  const overlay = document.getElementById('loadingOverlay');
  overlay.classList.remove('hidden');
  document.getElementById('calcBtn').disabled = true;

  try {
    const D = haversine(a.lat, a.lng, b.lat, b.lng);

    // Build exactly N_SAMPLES+1 = 100 points
    const points = [];
    for (let i=0; i<=N_SAMPLES; i++) {
      const f = i/N_SAMPLES;
      points.push([lerp(a.lat,b.lat,f), lerp(a.lng,b.lng,f)]);
    }

    // Build cache key from endpoints rounded to 4dp (~11m precision)
    const _cKey = `${a.lat.toFixed(4)},${a.lng.toFixed(4)},${b.lat.toFixed(4)},${b.lng.toFixed(4)}`;
    let elev, dists;
    if (_elevCache[_cKey]) {
      // Cache hit ‚Äî reuse elevation data, skip API call entirely
      elev  = _elevCache[_cKey].elev;
      dists = _elevCache[_cKey].dists;
      document.getElementById('loadingText').textContent = 'Using cached elevation‚Ä¶';
    } else {
      // Cache miss ‚Äî fetch from API
      document.getElementById('loadingText').textContent = 'Fetching elevation data‚Ä¶';
      elev  = await fetchElevations(points);
      dists = points.map((_,i) => (i/N_SAMPLES)*D);
      // Store in cache (keep last 5 unique paths to avoid unbounded growth)
      if (Object.keys(_elevCache).length >= 5) {
        delete _elevCache[Object.keys(_elevCache)[0]];
      }
      _elevCache[_cKey] = { elev, dists };
      _elevCacheKey = _cKey;
    }

    const antA = elev[0]+hA, antB = elev[N_SAMPLES]+hB;
    const losLine=[], blocked=[];
    let anyBlocked=false, minClear=Infinity, maxBulge=0;

    for (let i=0; i<=N_SAMPLES; i++) {
      const d=dists[i], f=d/D;
      const losH = lerp(antA, antB, f);
      losLine.push(losH);
      const bg = bulge(d,D);
      if (bg>maxBulge) maxBulge=bg;
      const clear = losH-(elev[i]+bg);
      if (clear<minClear) minClear=clear;
      blocked.push(clear<0);
      if (clear<0) anyBlocked=true;
    }

    // ‚îÄ‚îÄ Diffraction analysis ‚îÄ‚îÄ
    const band    = FREQ_BANDS[currentBand];
    const diffr   = computeDiffraction(dists, elev, losLine, D, band.lambda);
    const grade   = linkGrade(diffr.nu, minClear, anyBlocked);

    drawSegmentedPath(points.map(p=>[p[0],p[1]]), blocked);
    map.fitBounds(L.latLngBounds([a.lat,a.lng],[b.lat,b.lng]).pad(0.3));
    // Always store raw data ‚Äî drawChart may silently fail if canvas is hidden (display:none)
    chartData = { dists, terrain: elev, losLine, blocked, points };
    drawChart(dists, elev, losLine, blocked, points);

    // ‚îÄ‚îÄ Status card ‚îÄ‚îÄ
    const bear = bearing(a.lat,a.lng,b.lat,b.lng);
    document.getElementById('resultsSection').style.display='block';
    document.getElementById('losCard').className = 'los-card los-'+grade.grade;
    document.getElementById('losIcon').textContent  = grade.icon;
    document.getElementById('losTitle').textContent = grade.label;
    document.getElementById('losDesc').textContent  = grade.desc;

    // ‚îÄ‚îÄ Header badge ‚îÄ‚îÄ
    const badge = document.getElementById('headerBadge');
    badge.className   = 'badge badge-'+grade.grade;
    badge.textContent = grade.label;

    // ‚îÄ‚îÄ Link quality meter ‚îÄ‚îÄ
    const meterEl = document.getElementById('linkMeter');
    meterEl.style.display = 'block';
    const fillEl = document.getElementById('linkMeterFill');
    const meterColors = { excellent:'#00e5ff', good:'#69ff47', fair:'#ffe066', poor:'#ff9f43', unlikely:'#ff6b35' };
    fillEl.style.width      = grade.pct + '%';
    fillEl.style.background = meterColors[grade.grade];

    const diffrInfoEl = document.getElementById('linkDiffInfo');
    if (anyBlocked) {
      const lossStr  = diffr.lossDb.toFixed(1);
      const nuStr    = diffr.nu.toFixed(2);
      const obsFt    = diffr.obstacleIdx > 0 ? fmtFt(elev[diffr.obstacleIdx] - losLine[diffr.obstacleIdx]) : '‚Äî';
      diffrInfoEl.innerHTML = `ŒΩ=${nuStr} ¬∑ Est. diffraction loss: <strong style="color:${meterColors[grade.grade]}">${lossStr} dB</strong><br>`
        + `Band: ${band.label} (Œª=${band.lambda.toFixed(2)}m) ¬∑ Worst obstacle: ${obsFt} above LOS`;
    } else {
      const fresnelPct = diffr.nu <= -0.78 ? '‚â•60%' : diffr.nu <= 0 ? '40‚Äì60%' : '<40%';
      diffrInfoEl.innerHTML = `LOS clear ¬∑ Fresnel zone clearance: <strong style="color:#69ff47">${fresnelPct}</strong><br>`
        + `Band: ${band.label} ¬∑ ŒΩ=${diffr.nu.toFixed(2)}`;
    }

    // ‚îÄ‚îÄ Diffraction loss stat card ‚îÄ‚îÄ
    if (anyBlocked) {
      document.getElementById('diffrCard').style.display = 'block';
      const dEl = document.getElementById('statDiffr');
      dEl.textContent = diffr.lossDb.toFixed(1) + ' dB (estimated, knife-edge model)';
      dEl.className = 'stat-value ' + (diffr.lossDb < 15 ? 'sv-b' : diffr.lossDb < 25 ? '' : 'sv-warn');
    } else {
      document.getElementById('diffrCard').style.display = 'none';
    }

    // ‚îÄ‚îÄ Link Budget ‚îÄ‚îÄ
    renderLinkBudget(D, FREQ_BANDS[currentBand].freqMHz, diffr.lossDb, diffr.nu,
                     elev, dists, losLine, FREQ_BANDS[currentBand].lambda);

    // ‚îÄ‚îÄ Stat values (imperial primary) ‚îÄ‚îÄ
    document.getElementById('statDist').textContent    = fmtDist(D, false);
    document.getElementById('statBearing').textContent = bear.toFixed(1)+'¬∞';
    document.getElementById('statElevA').textContent   = fmtFtM(elev[0]);
    document.getElementById('statElevB').textContent   = fmtFtM(elev[N_SAMPLES]);
    document.getElementById('statMaxT').textContent    = fmtFtM(Math.max(...elev));
    document.getElementById('statBulge').textContent   = fmtFtM(maxBulge);

    const clEl = document.getElementById('statClear');
    clEl.textContent = fmtClearFtM(minClear) + (minClear >= 0 ? ' above LOS' : ' BELOW LOS');
    clEl.className   = 'stat-value '+(minClear>=0?'sv-b':'sv-warn');

  } catch(err) {
    console.error('Analysis error:', err);
    const badge = document.getElementById('headerBadge');
    badge.className='badge badge-idle'; badge.textContent='ERROR';

    let msg = 'Could not fetch elevation data.\n\n';
    if (err.message.includes('Failed to fetch') || err.message.includes('NetworkError')) {
      msg += window.location.protocol === 'file:'
        ? 'This may be a CORS restriction when opening from a local file.\nTry opening via a local web server (see the note in the panel).'
        : 'Check your internet connection and try again.';
    } else {
      msg += err.message;
    }
    alert(msg);

  } finally {
    document.getElementById('loadingOverlay').classList.add('hidden');
    document.getElementById('calcBtn').disabled = false;
    _analysisRunning = false;
  }
}


// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// LINK BUDGET
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// LINK BUDGET
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// LINK BUDGET
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// ‚îÄ‚îÄ State: unit modes ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const _lbState = {
  txLossUnit: 'db',   // 'db' or 'w'
  txAntUnit:  'dbd',  // 'dbd' or 'dbi'
};

// ‚îÄ‚îÄ Panel toggle (open by default) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function toggleLinkBudget() {
  const body = document.getElementById('lbBody');
  const icon = document.getElementById('lbToggleIcon');
  const peek = document.getElementById('lbCollapsedPeek');
  const open = body.style.display === 'none';
  body.style.display  = open ? 'block' : 'none';
  icon.textContent    = open ? '‚ñ≤ COLLAPSE' : '‚ñº EXPAND';
  if (peek) peek.style.display = open ? 'none' : 'block';
}

// ‚îÄ‚îÄ Toggle feedline loss unit: dB ‚Üî W-lost ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function lbSetLossUnit(unit) {
  if (unit === _lbState.txLossUnit) return;
  const prev   = _lbState.txLossUnit;
  _lbState.txLossUnit = unit;

  const input  = document.getElementById('lbTxLossVal');
  const curVal = parseFloat(input.value) || 0;
  const txPowW = parseFloat(document.getElementById('lbTxPow').value) || 5;

  if (unit === 'w') {
    // dB ‚Üí watts lost
    const wLost = txPowW * (1 - Math.pow(10, -curVal / 10));
    input.value = Math.min(wLost, txPowW * 0.999).toFixed(1);
    input.min = '0'; input.step = '0.5';
  } else {
    // watts lost ‚Üí dB
    const eff = Math.max(0.001, 1 - curVal / txPowW);
    input.value = (-10 * Math.log10(eff)).toFixed(1);
    input.min = '0'; input.step = '0.1';
  }

  document.getElementById('lbTxLossUnitDb').classList.toggle('lb-unit-active', unit === 'db');
  document.getElementById('lbTxLossUnitW' ).classList.toggle('lb-unit-active', unit === 'w');
  lbUpdateDerived();
}

// ‚îÄ‚îÄ Toggle antenna gain unit: dBd ‚Üî dBi ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function lbSetAntUnit(unit) {
  if (unit === _lbState.txAntUnit) return;
  _lbState.txAntUnit = unit;

  const input  = document.getElementById('lbTxAntCustom');
  const curVal = parseFloat(input.value) || 0;
  input.value  = unit === 'dbi' ? (curVal + 2.15).toFixed(2) : (curVal - 2.15).toFixed(2);

  document.getElementById('lbTxAntUnitDbd').classList.toggle('lb-unit-active', unit === 'dbd');
  document.getElementById('lbTxAntUnitDbi').classList.toggle('lb-unit-active', unit === 'dbi');
  lbUpdateDerived();
}

// ‚îÄ‚îÄ Get TX loss in dB from whichever mode is active ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function _getTxLossDb() {
  const val    = parseFloat(document.getElementById('lbTxLossVal').value) || 0;
  if (_lbState.txLossUnit === 'db') return val;
  const txPowW = parseFloat(document.getElementById('lbTxPow').value) || 5;
  const eff    = Math.max(0.001, 1 - val / txPowW);
  return -10 * Math.log10(eff);
}

// ‚îÄ‚îÄ Get TX antenna gain in dBd from dropdown or custom ‚îÄ‚îÄ‚îÄ
function _getTxGainDbd() {
  const sel = document.getElementById('lbTxAnt').value;
  if (sel !== 'custom') return parseFloat(sel) || 0;
  const raw = parseFloat(document.getElementById('lbTxAntCustom').value) || 0;
  return _lbState.txAntUnit === 'dbi' ? raw - 2.15 : raw;
}

// ‚îÄ‚îÄ Format watts compactly ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function fmtW(w) {
  if (w >= 1000)  return (w / 1000).toFixed(1) + ' kW';
  if (w >= 100)   return w.toFixed(0) + ' W';
  if (w >= 10)    return w.toFixed(1) + ' W';
  if (w >= 0.1)   return w.toFixed(2) + ' W';
  return (w * 1000).toFixed(1) + ' mW';
}

// ‚îÄ‚îÄ Read full link budget ‚Üí return object ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function getLinkBudget() {
  const txPowW    = parseFloat(document.getElementById('lbTxPow').value) || 5;
  const txLossDb  = _getTxLossDb();
  const txGainDbd = _getTxGainDbd();
  const txGainDbi = txGainDbd + 2.15;

  const sensSel   = document.getElementById('lbRxSens').value;
  const rxSensDbm = sensSel === 'custom'
    ? (parseFloat(document.getElementById('lbRxSensCustom').value) || -107)
    : parseFloat(sensSel);

  // ERP (watts, referenced to dipole)
  const txLineEff = Math.pow(10, -txLossDb / 10);
  const erpW      = txPowW * Math.pow(10, txGainDbd / 10) * txLineEff;

  // EIRP (dBm) ‚Äî used internally with FSPL math
  const txPowDbm = 10 * Math.log10(txPowW * 1000);
  const eirpDbm  = txPowDbm + txGainDbi - txLossDb;

  return { txPowW, txPowDbm, txGainDbd, txGainDbi, txLossDb,
           rxSensDbm, eirpDbm, erpW };
}

// ‚îÄ‚îÄ Update all live readouts ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function lbUpdateDerived() {
  const txPowW   = parseFloat(document.getElementById('lbTxPow').value) || 5;
  const txLossDb = _getTxLossDb();
  const txEff    = Math.pow(10, -txLossDb / 10);
  const wToAnt   = txPowW * txEff;

  // Feedline conversion note
  const note = document.getElementById('lbTxLossNote');
  if (_lbState.txLossUnit === 'db') {
    note.textContent = `‚âà ${(txEff*100).toFixed(0)}% efficient ¬∑ delivering ${fmtW(wToAnt)} to antenna`;
  } else {
    const lostW = parseFloat(document.getElementById('lbTxLossVal').value) || 0;
    note.textContent = `${fmtW(lostW)} dissipated in feedline ¬∑ ${fmtW(Math.max(0, txPowW - lostW))} to antenna`;
  }

  // Antenna conversion note (custom only)
  const antSel  = document.getElementById('lbTxAnt').value;
  const antNote = document.getElementById('lbTxAntNote');
  if (antSel === 'custom') {
    const dbd = _getTxGainDbd();
    antNote.textContent = _lbState.txAntUnit === 'dbd'
      ? `= ${(dbd + 2.15).toFixed(2)} dBi`
      : `= ${dbd.toFixed(2)} dBd`;
    antNote.style.display = 'block';
  } else {
    antNote.style.display = 'none';
  }

  // ERP
  const lb = getLinkBudget();
  document.getElementById('lbErpVal').textContent = fmtW(lb.erpW) + ' ERP';

  // NOTE: deliberately does NOT call runAnalysis() ‚Äî link budget is recalculated
  // from current input values when the Calculate button is pressed. This prevents
  // every keystroke in the power/loss fields from triggering an elevation API call.
}

// ‚îÄ‚îÄ Antenna dropdown change ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function lbAntennaChange() {
  const sel = document.getElementById('lbTxAnt').value;
  document.getElementById('lbTxAntCustomRow').style.display = sel === 'custom' ? 'flex' : 'none';
  lbUpdateDerived();
}

// ‚îÄ‚îÄ Sensitivity dropdown change ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function lbSensChange() {
  document.getElementById('lbRxSensCustomRow').style.display =
    document.getElementById('lbRxSens').value === 'custom' ? 'flex' : 'none';
  lbUpdateDerived();
}

// ‚îÄ‚îÄ Free Space Path Loss ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function computeFSPL(distMeters, freqMHz) {
  if (distMeters <= 0) return 0;
  return 20 * Math.log10(distMeters) + 20 * Math.log10(freqMHz * 1e6) - 147.55;
}

// ‚îÄ‚îÄ Render the link budget result card ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function renderLinkBudget(distMeters, freqMHz, diffrLossDb, nuVal,
                          elevations, dists, losLine, lambda) {
  const lb   = getLinkBudget();
  const fspl = computeFSPL(distMeters, freqMHz);

  // ‚îÄ‚îÄ Knife-edge loss (positive dB) ‚îÄ‚îÄ
  const keLoss   = Math.max(0, -diffrLossDb);
  const rsl      = lb.eirpDbm - fspl - keLoss;
  const keMargin = rsl - lb.rxSensDbm;

  // ‚îÄ‚îÄ Terrain corrections (only when path is obstructed) ‚îÄ‚îÄ
  let deygout   = { extraLossDb: 0, nPeaks: 1 };
  let roughness = { lossDb: 0, deltaH: 0 };
  let hasCorrected = false;

  if (nuVal > 0.5 && elevations && dists && losLine) {
    deygout   = computeDeygout(dists, elevations, losLine, distMeters, lambda);
    roughness = computeTerrainRoughness(elevations, distMeters, freqMHz);
    hasCorrected = deygout.extraLossDb > 0.5 || roughness.lossDb > 0.5;
  }

  const combinedCorrection = Math.min(deygout.extraLossDb + roughness.lossDb, 28.0);
  const correctedMargin    = keMargin - combinedCorrection;

  // ‚îÄ‚îÄ Primary margin: corrected when available, KE otherwise ‚îÄ‚îÄ
  const primaryMargin = hasCorrected ? correctedMargin : keMargin;
  const primaryLabel  = hasCorrected ? 'dB est. margin (terrain-corrected)' : 'dB link margin';

  // ‚îÄ‚îÄ Card colour ‚îÄ‚îÄ
  const card = document.getElementById('lbResultCard');
  card.className = 'lbr-card visible ' +
    (primaryMargin >= 15 ? 'lbr-pass' : primaryMargin >= 0 ? 'lbr-marginal' : 'lbr-fail');

  document.getElementById('lbrMarginVal').textContent =
    (primaryMargin >= 0 ? '+' : '') + primaryMargin.toFixed(1);
  document.getElementById('lbrMarginLabel').textContent = primaryLabel;

  // ‚îÄ‚îÄ Verdict ‚îÄ‚îÄ
  const terrainHard = nuVal > 3.0;
  let verdict, hint;
  if (terrainHard && primaryMargin < 20) {
    verdict = 'üèîÔ∏è Terrain blocks this path';
    hint    = keLoss > 25
      ? `The terrain is far above the line of sight ‚Äî no practical amount of power can overcome this.`
      : `Heavy terrain loss. Even high-power stations would struggle here.`;
  } else if (primaryMargin >= 20) {
    verdict = '‚úÖ Solid link ‚Äî excellent margin';
    hint    = `Your ${fmtW(lb.erpW)} ERP arrives well above the receiver threshold. Robust and reliable.`;
  } else if (primaryMargin >= 10) {
    verdict = '‚úÖ Good link ‚Äî adequate margin';
    hint    = `Should work reliably under normal conditions. Some fading expected.`;
  } else if (primaryMargin >= 0) {
    verdict = '‚ö†Ô∏è Marginal ‚Äî expect heavy static';
    hint    = `Signal near the noise floor. Copy will be difficult; conditions matter a lot.`;
  } else {
    const needWatts = lb.txPowW * Math.pow(10, Math.abs(primaryMargin) / 10);
    verdict = 'üî¥ Link budget fails';
    hint = terrainHard
      ? `Terrain obstruction (ŒΩ=${nuVal.toFixed(1)}) is the primary blocker. Power alone cannot fix this.`
      : `Need ${Math.abs(primaryMargin).toFixed(1)} dB more. Power alone: ~${fmtW(needWatts)} TX.`;
  }
  document.getElementById('lbrVerdict').innerHTML = verdict;

  // ‚îÄ‚îÄ Budget table ‚îÄ‚îÄ
  const txAntDbd = lb.txGainDbd.toFixed(2);
  const txAntDbi = lb.txGainDbi.toFixed(2);
  const rows = [
    { label: 'TX Output',       sign: '+', val: fmtW(lb.txPowW),                               cls: 'pos' },
    { label: 'TX Line Loss',    sign: '‚àí', val: lb.txLossDb.toFixed(1) + ' dB',                cls: lb.txLossDb > 0.2 ? 'neg' : '' },
    { label: 'TX Antenna',      sign: '+', val: `${txAntDbd} dBd  (${txAntDbi} dBi)`,          cls: 'pos' },
    { label: 'ERP',             sign: '=', val: fmtW(lb.erpW),                                  cls: 'neu', bold: true },
    { label: 'Free Space Loss', sign: '‚àí', val: fspl.toFixed(1) + ' dB',                       cls: 'neg' },
    { label: 'Knife-Edge Loss', sign: '‚àí', val: keLoss.toFixed(1) + ' dB',                     cls: keLoss > 3 ? 'neg' : '' },
    { label: 'Received Signal', sign: '=', val: rsl.toFixed(1) + ' dBm',                       cls: rsl >= lb.rxSensDbm ? 'pos' : 'neg', bold: true },
    { label: 'RX Sensitivity',  sign: '‚Üì', val: lb.rxSensDbm.toFixed(0) + ' dBm min',         cls: '' },
  ];

  if (hasCorrected) {
    // Correction rows (italic, orange)
    if (deygout.extraLossDb > 0.5) {
      const pd = deygout.nPeaks === 1 ? '1 obstacle' : `${deygout.nPeaks} obstacles`;
      rows.push({ label: `Deygout (${pd})`, sign: '‚àí', val: deygout.extraLossDb.toFixed(1) + ' dB', cls: 'neg', italic: true });
    }
    if (roughness.lossDb > 0.5) {
      rows.push({ label: `Œîh roughness (${roughness.deltaH.toFixed(0)}m)`, sign: '‚àí', val: roughness.lossDb.toFixed(1) + ' dB', cls: 'neg', italic: true });
    }
    // Corrected margin = main total
    rows.push({ label: 'Est. Margin', sign: '‚ñ∂',
      val: (correctedMargin >= 0 ? '+' : '') + correctedMargin.toFixed(1) + ' dB',
      cls: correctedMargin >= 15 ? 'pos' : correctedMargin >= 0 ? 'neu' : 'neg',
      bold: true, total: true });
    // KE margin = small muted footnote
    rows.push({ label: 'KE only (single-obstacle ref.)', sign: '',
      val: (keMargin >= 0 ? '+' : '') + keMargin.toFixed(1) + ' dB',
      cls: 'muted', footnote: true });
  } else {
    rows.push({ label: 'Link Margin', sign: '‚ñ∂',
      val: (keMargin >= 0 ? '+' : '') + keMargin.toFixed(1) + ' dB',
      cls: keMargin >= 15 ? 'pos' : keMargin >= 0 ? 'neu' : 'neg',
      bold: true, total: true });
  }

  document.getElementById('lbrTableBody').innerHTML = rows.map(r => {
    const trCls = r.total ? 'lbr-total' : r.footnote ? 'lbr-footnote' : '';
    const style = [r.bold ? 'font-weight:700' : '', r.italic ? 'font-style:italic' : ''].filter(Boolean).join(';');
    return `<tr class="${trCls}">
      <td class="td-label">${r.label}</td>
      <td class="td-sign">${r.sign}</td>
      <td class="td-val ${r.cls}" ${style ? `style="${style}"` : ''}>${r.val}</td>
    </tr>`;
  }).join('');

  // ‚îÄ‚îÄ Correction footnote ‚îÄ‚îÄ
  const bkEl = document.getElementById('lbrCorrectionBreakdown');
  if (hasCorrected) {
    bkEl.textContent = '¬± 5 dB uncertainty ¬∑ ITU-R P.526 Deygout + P.1546 Œîh model';
    bkEl.style.display = 'block';
  } else {
    bkEl.style.display = 'none';
  }

  document.getElementById('lbrHint').innerHTML = hint;
}

// ‚îÄ‚îÄ Initialize on page load ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function initLinkBudget() {
  lbUpdateDerived();
}
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// REPEATER LOOKUP
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê


// ‚îÄ‚îÄ Set this to your deployed Cloudflare Worker URL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// e.g. 'https://rf-los-proxy.yourname.workers.dev'
// Leave empty to show the setup note in the UI.
const REPEATER_PROXY = 'https://rf-los.myz06vette.workers.dev';

// Internal: results cache + current selection
let _rptrResults = [];   // array of repeater objects from last lookup
let _rptrSelected = null; // the currently chosen repeater object

// Show/hide note if proxy is not configured
function _checkProxyConfig() {
  const note = document.getElementById('rptrProxyNote');
  if (note) note.style.display = REPEATER_PROXY ? 'none' : 'block';
}

// Toggle Site B between Manual and Repeater modes
function setSiteBMode(mode) {
  const manual   = document.getElementById('siteBManual');
  const repeater = document.getElementById('siteBRepeater');
  const licensee = document.getElementById('siteBLicensee');
  const grid     = document.getElementById('siteBGrid');
  const btnM     = document.getElementById('siteBModeManual');
  const btnR     = document.getElementById('siteBModeRepeater');
  const btnL     = document.getElementById('siteBModeLicensee');
  const btnG     = document.getElementById('siteBModeGrid');

  // Hide all panels, deactivate all buttons
  [manual, repeater, licensee, grid].forEach(el => { if (el) el.style.display = 'none'; });
  [btnM, btnR, btnL, btnG].forEach(el => { if (el) el.classList.remove('mode-active'); });

  if (mode === 'repeater') {
    repeater.style.display = 'block';
    btnR.classList.add('mode-active');
    _checkProxyConfig();
  } else if (mode === 'licensee') {
    licensee.style.display = 'block';
    if (btnL) btnL.classList.add('mode-active');
  } else if (mode === 'grid') {
    if (grid) grid.style.display = 'block';
    if (btnG) btnG.classList.add('mode-active');
  } else {
    manual.style.display = 'block';
    btnM.classList.add('mode-active');
  }
}

// Map RepeaterBook frequency ‚Üí closest freq band key
function freqToband(freqMHz) {
  const f = parseFloat(freqMHz);
  if (f >= 29   && f < 90 ) return 'vhf-low';
  if (f >= 136  && f < 175) return 'vhf-high';
  if (f >= 216  && f < 226) return 'vhf-high';  // 1.25m band ‚Äî closest match
  if (f >= 400  && f < 520) return 'uhf-low';
  if (f >= 700  && f < 960) return 'uhf-high';
  return null; // out of supported range
}

// Render the repeater result card for a given repeater object
function renderRepeaterCard(r) {
  _rptrSelected = r;

  // Populate lat/lng
  document.getElementById('latB').value = parseFloat(r.Lat).toFixed(5);
  document.getElementById('lngB').value = parseFloat(r.Long).toFixed(5);

  // Update marker
  if (typeof markerB !== 'undefined' && markerB) {
    markerB.setLatLng([parseFloat(r.Lat), parseFloat(r.Long)]);
  }

  // Auto-set frequency band
  const band = freqToband(r.Frequency || r['Output Frequency'] || '');
  if (band) setFreqBand(band);

  // Build offset string
  const freqOut = parseFloat(r.Frequency || r['Output Frequency'] || 0).toFixed(4);
  const freqIn  = parseFloat(r['Input Freq'] || r['Input Frequency'] || 0);
  let offsetStr = '';
  if (freqIn && freqOut) {
    const diff = (freqIn - parseFloat(freqOut));
    const sign = diff >= 0 ? '+' : '';
    offsetStr = ` / input: ${parseFloat(freqIn).toFixed(4)} (${sign}${diff.toFixed(3)})`;
  }
  const pl = r.PL || r['CTCSS'] || '';
  const plStr = pl && pl !== '0' && pl !== '0.0' ? `  PL: ${pl} Hz` : '';

  document.getElementById('rptrCardCall').textContent  = r.Callsign || r['Call Sign'] || '‚Äî';
  document.getElementById('rptrCardFreq').textContent  = `${freqOut} MHz${offsetStr}${plStr}`;
  const landmark = r.Landmark ? ` (${r.Landmark})` : '';
  document.getElementById('rptrCardLoc').textContent   =
    `${r['Nearest City'] || r.City || ''}${r.State ? ', ' + r.State : ''}${landmark}`;

  // Badges
  const badgesEl = document.getElementById('rptrCardBadges');
  badgesEl.innerHTML = '';
  const use = (r.Use || '').toUpperCase();
  if (use === 'OPEN' || use === 'YES') {
    badgesEl.innerHTML += '<span class="rptr-badge rptr-badge-open">Open</span>';
  } else if (use && use !== 'UNKNOWN') {
    badgesEl.innerHTML += '<span class="rptr-badge rptr-badge-closed">' + use + '</span>';
  }
  // Mode badges
  const modes = [
    ['FM Analog','FM'],['System Fusion','Fusion'],['DMR','DMR'],
    ['D-Star','D-STAR'],['NXDN','NXDN'],['APCO P-25','P25'],['M17','M17'],
  ];
  modes.forEach(([key, label]) => {
    if ((r[key] || '').toLowerCase() === 'yes') {
      badgesEl.innerHTML += `<span class="rptr-badge rptr-badge-mode">${label}</span>`;
    }
  });
  // GMRS tag
  if ((r['Service'] || '').toLowerCase() === 'gmrs' || document.getElementById('rptrType').value === 'gmrs') {
    badgesEl.innerHTML += '<span class="rptr-badge rptr-badge-gmrs">GMRS</span>';
  }

  document.getElementById('rptrCard').classList.add('visible');

  // Trigger analysis
  document.getElementById('addrStatusBRepeater').textContent = '';
  runAnalysis();
}

// Handle picker selection
function selectRepeaterResult(idx) {
  const r = _rptrResults[parseInt(idx)];
  if (r) renderRepeaterCard(r);
}

// Main lookup function
async function lookupRepeater() {
  const callsign = document.getElementById('rptrCallsign').value.trim().toUpperCase();
  const type     = document.getElementById('rptrType').value;
  const statusEl = document.getElementById('rptrStatus');
  const cardEl   = document.getElementById('rptrCard');
  const pickerEl = document.getElementById('rptrPicker');

  if (!callsign) {
    statusEl.textContent = '‚ö† Enter a callsign first';
    statusEl.className   = 'rptr-status err';
    return;
  }

  if (!REPEATER_PROXY) {
    statusEl.textContent = '‚ö† Proxy not configured ‚Äî see setup note above';
    statusEl.className   = 'rptr-status err';
    return;
  }

  // Reset UI
  cardEl.classList.remove('visible');
  document.getElementById('rptrPicker').classList.remove('visible');
  statusEl.textContent = '‚è≥ Looking up ' + callsign + '‚Ä¶';
  statusEl.className   = 'rptr-status';
  document.getElementById('rptrLookupBtn').disabled = true;

  try {
    const url  = `${REPEATER_PROXY}?callsign=${encodeURIComponent(callsign)}&type=${type}`;
    const resp = await fetch(url);
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    const data = await resp.json();

    if (data.error) throw new Error(data.error);

    const results = (data.results || []).filter(r =>
      r.Lat && r.Long && parseFloat(r.Lat) !== 0 && parseFloat(r.Long) !== 0
    );

    _rptrResults = results;

    if (results.length === 0) {
      statusEl.textContent = `‚úó No ${type === 'gmrs' ? 'GMRS' : 'amateur'} repeaters found for ${callsign}`;
      statusEl.className   = 'rptr-status err';
      return;
    }

    statusEl.textContent = `‚úì Found ${results.length} repeater${results.length > 1 ? 's' : ''}`;
    statusEl.className   = 'rptr-status ok';

    if (results.length === 1) {
      // Auto-select the only result
      renderRepeaterCard(results[0]);
    } else {
      // Show picker for multiple results
      const picker = document.getElementById('rptrPicker');
      const sel    = document.getElementById('rptrPickerSelect');
      sel.innerHTML = results.map((r, i) => {
        const freq = parseFloat(r.Frequency || r['Output Frequency'] || 0).toFixed(4);
        const loc  = `${r['Nearest City'] || r.City || ''}${r.State ? ', ' + r.State : ''}`;
        return `<option value="${i}">${r.Callsign}  ${freq} MHz  ‚Äî  ${loc}</option>`;
      }).join('');
      picker.classList.add('visible');
      renderRepeaterCard(results[0]);  // auto-select first
    }

  } catch (err) {
    statusEl.textContent = `‚úó Lookup failed: ${err.message}`;
    statusEl.className   = 'rptr-status err';
  } finally {
    document.getElementById('rptrLookupBtn').disabled = false;
  }
}


// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// LICENSEE LOOKUP (ham via HamDB, GMRS via FCC ULS)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

async function lookupLicensee() {
  const callsign  = document.getElementById('licCallsign').value.trim().toUpperCase();
  const statusEl  = document.getElementById('licStatus');
  const cardEl    = document.getElementById('licCard');

  if (!callsign) {
    statusEl.textContent = '‚ö† Enter a callsign first';
    statusEl.className   = 'lic-status err';
    return;
  }
  if (!REPEATER_PROXY) {
    statusEl.textContent = '‚ö† Proxy not configured';
    statusEl.className   = 'lic-status err';
    return;
  }

  cardEl.classList.remove('visible');
  statusEl.textContent = '‚è≥ Looking up ' + callsign + '‚Ä¶';
  statusEl.className   = 'lic-status';
  document.getElementById('licLookupBtn').disabled = true;

  try {
    const url  = `${REPEATER_PROXY}?callsign=${encodeURIComponent(callsign)}&type=licensee`;
    const resp = await fetch(url);
    const data = await resp.json();

    // Special case: GMRS callsigns have no public API.
    // Worker returns 422 with error:'GMRS_NO_API' and a direct FCC search URL.
    if (data.error === 'GMRS_NO_API') {
      const fccUrl = data.fccUrl || `https://wireless2.fcc.gov/UlsApp/UlsSearch/searchLicense.jsp`;
      statusEl.innerHTML =
        `‚ö† GMRS callsigns cannot be looked up via API ‚Äî the FCC provides no public endpoint for GMRS data.<br>` +
        `<a href="${fccUrl}" target="_blank" rel="noopener" style="color:#ffe066;text-decoration:underline;">` +
        `üîó Search FCC ULS for ${callsign} ‚Üí</a>`;
      statusEl.className = 'lic-status err';
      return;
    }

    if (data.error) throw new Error(data.error);

    const isGmrs    = data.source === 'fcc_uls';
    const addrParts = [data.addr1, data.addr2, data.state, data.zip].filter(Boolean);
    const addrStr   = addrParts.join(', ');

    // Build badges
    const badgesEl = document.getElementById('licCardBadges');
    badgesEl.innerHTML = isGmrs
      ? '<span class="lic-badge lic-badge-gmrs">GMRS</span>'
      : '<span class="lic-badge lic-badge-ham">Amateur</span>';
    if (data.class && !isGmrs) {
      const classLabels = { T:'Technician', G:'General', A:'Advanced', E:'Extra' };
      const label = classLabels[data.class] || data.class;
      badgesEl.innerHTML += `<span class="lic-badge lic-badge-class">${label}</span>`;
    }

    document.getElementById('licCardCall').textContent = data.callsign || callsign;
    document.getElementById('licCardName').textContent =
      [data.fname, data.name].filter(Boolean).join(' ') || data.name || '‚Äî';
    document.getElementById('licCardAddr').textContent = addrStr || 'Address not available';

    cardEl.classList.add('visible');
    statusEl.textContent = `‚úì Found: ${data.callsign}`;
    statusEl.className   = 'lic-status ok';

    // callook.info returns pre-geocoded lat/lon ‚Äî use directly, no geocoding step needed
    if (data.lat && data.lon) {
      const lat = parseFloat(data.lat);
      const lon = parseFloat(data.lon);
      document.getElementById('latB').value = lat.toFixed(5);
      document.getElementById('lngB').value = lon.toFixed(5);
      if (typeof markerB !== 'undefined' && markerB) markerB.setLatLng([lat, lon]);
      const noteText = data.grid
        ? `üìç FCC address geocoded ¬∑ Grid: ${data.grid}`
        : 'üìç FCC address geocoded ¬∑ location is approximate';
      document.getElementById('licCardNote').textContent = noteText;
      document.getElementById('addrStatusBLicensee').textContent = '';
      runAnalysis();
    } else if (addrStr) {
      // Fallback: geocode manually if callook didn't return coords
      document.getElementById('licCardNote').textContent = '‚è≥ Geocoding address‚Ä¶';
      geocodeLicenseeAddress(addrStr, data.callsign);
    } else {
      document.getElementById('licCardNote').textContent = '‚ö† No coordinates available ‚Äî enter manually';
    }

  } catch (err) {
    statusEl.textContent = `‚úó Lookup failed: ${err.message}`;
    statusEl.className   = 'lic-status err';
  } finally {
    document.getElementById('licLookupBtn').disabled = false;
  }
}

async function geocodeLicenseeAddress(addrStr, callsign) {
  const noteEl = document.getElementById('licCardNote');
  // Use the same ArcGIS geocoder already in the tool
  const url = `https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer/findAddressCandidates`
    + `?SingleLine=${encodeURIComponent(addrStr)}&f=json&outFields=&maxLocations=1`;
  try {
    const resp = await fetch(url);
    const data = await resp.json();
    const cand = data?.candidates?.[0];
    if (!cand || cand.score < 60) throw new Error('Address geocoding returned no confident result');

    const lat = cand.location.y, lon = cand.location.x;
    document.getElementById('latB').value = lat.toFixed(5);
    document.getElementById('lngB').value = lon.toFixed(5);
    if (typeof markerB !== 'undefined' && markerB) markerB.setLatLng([lat, lon]);
    noteEl.textContent = `üìç Geocoded from address (${addrStr})`;
    document.getElementById('addrStatusBLicensee').textContent = '';
    runAnalysis();
  } catch (err) {
    noteEl.textContent = `‚ö† Geocoding failed: ${err.message} ‚Äî enter coordinates manually`;
    document.getElementById('addrStatusBLicensee').textContent = '';
  }
}


// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MAIDENHEAD GRID SQUARE LOOKUP
// Pure JS ‚Äî no external API needed.
// Converts a grid square string to lat/lng of its CENTER point.
// Supports 4-char (field+square, ~3¬∞√ó5¬∞ ‚âà ~70mi) and
// 6-char (field+square+subsquare, ~0.25¬∞√ó0.5¬∞ ‚âà ~3-15mi) grids.
// Reference: ARRL/ITU Maidenhead Locator System
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

/**
 * Parse a Maidenhead grid square string ‚Üí { lat, lng, sizeLat, sizeLng }
 * Returns null on invalid input.
 */
function gridSquareToLatLng(grid) {
  if (!grid || grid.length < 4) return null;
  const g = grid.toUpperCase();

  // Validate characters
  if (!/^[A-R]{2}[0-9]{2}([A-X]{2})?$/.test(g)) return null;

  // Field (chars 0-1): A-R ‚Üí longitude -180 to +180 in 20¬∞ steps
  //                         latitude  -90  to +90  in 10¬∞ steps
  const f1 = g.charCodeAt(0) - 65;  // 0-17 (A=0, R=17)
  const f2 = g.charCodeAt(1) - 65;  // 0-17
  let lng = f1 * 20 - 180;
  let lat = f2 * 10 - 90;

  // Square (chars 2-3): 0-9 ‚Üí 2¬∞ lon / 1¬∞ lat steps
  lng += parseInt(g[2]) * 2;
  lat += parseInt(g[3]) * 1;

  // Subsquare (chars 4-5, optional): A-X ‚Üí 5'/2.5' steps
  let sizeLng = 2, sizeLat = 1;
  if (g.length >= 6) {
    const s1 = g.charCodeAt(4) - 65;  // 0-23 (A=0, X=23)
    const s2 = g.charCodeAt(5) - 65;  // 0-23
    lng += s1 * (5/60);
    lat += s2 * (2.5/60);
    sizeLng = 5/60;
    sizeLat = 2.5/60;
  }

  // Center of the grid square
  const centerLng = lng + sizeLng / 2;
  const centerLat = lat + sizeLat / 2;

  return { lat: centerLat, lng: centerLng, sizeLat, sizeLng };
}

/** Format a precision note based on grid size */
function gridPrecisionNote(sizeLat, sizeLng) {
  // Convert degrees to approximate miles (1¬∞ lat ‚âà 69 mi, 1¬∞ lng ‚âà 69*cos(lat) mi)
  const latMi  = sizeLat * 69;
  const lngMi  = sizeLng * 69;
  const maxMi  = Math.max(latMi, lngMi);
  if (maxMi < 1) return `Grid precision: < 1 mile`;
  if (maxMi < 5) return `Grid precision: ~${maxMi.toFixed(0)} miles`;
  return `Grid precision: ~${Math.round(maxMi)} miles (${sizeLat.toFixed(sizeLat < 1 ? 2 : 0)}¬∞ lat √ó ${sizeLng.toFixed(sizeLng < 1 ? 2 : 0)}¬∞ lng)`;
}

/** Main lookup handler */
function lookupGridSquare() {
  const raw      = (document.getElementById('gridInput').value || '').trim().toUpperCase();
  const statusEl = document.getElementById('gridStatus');
  const cardEl   = document.getElementById('gridCard');

  // Reset
  cardEl.classList.remove('visible');
  statusEl.className = 'grid-status';

  // Validate length
  if (!raw) {
    statusEl.textContent = '‚ö† Enter a grid square (e.g. EM74 or EM74rj)';
    statusEl.className   = 'grid-status err';
    return;
  }
  if (raw.length !== 4 && raw.length !== 6) {
    statusEl.textContent = '‚ö† Grid square must be 4 or 6 characters (e.g. EM74 or EM74rj)';
    statusEl.className   = 'grid-status err';
    return;
  }

  const result = gridSquareToLatLng(raw);
  if (!result) {
    statusEl.textContent = `‚ö† "${raw}" is not a valid Maidenhead grid square`;
    statusEl.className   = 'grid-status err';
    return;
  }

  const { lat, lng, sizeLat, sizeLng } = result;

  // Update coordinates
  document.getElementById('latB').value = lat.toFixed(5);
  document.getElementById('lngB').value = lng.toFixed(5);
  if (typeof markerB !== 'undefined' && markerB) markerB.setLatLng([lat, lng]);

  // Populate card
  document.getElementById('gridCardSq').textContent = raw;
  document.getElementById('gridCardInfo').textContent =
    `Center: ${lat >= 0 ? lat.toFixed(4)+'¬∞N' : Math.abs(lat).toFixed(4)+'¬∞S'}, ` +
    `${lng >= 0 ? lng.toFixed(4)+'¬∞E' : Math.abs(lng).toFixed(4)+'¬∞W'}`;

  // Update precision note in card
  const noteEl = cardEl.querySelector('.grid-card-note');
  if (noteEl) noteEl.textContent = 'üìç ' + gridPrecisionNote(sizeLat, sizeLng);

  cardEl.classList.add('visible');

  const precLen = raw.length === 6 ? '6-char subsquare' : '4-char square';
  statusEl.textContent = `‚úì ${raw} decoded (${precLen})`;
  statusEl.className   = 'grid-status ok';

  // Run analysis
  runAnalysis();
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// BOOT
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
window.addEventListener('load', () => {
  initMap();
  setMapMode('off');
  initChartInteractivity();
  initLinkBudget();
  if (isMobile()) applyMobileLayout();
  // NOTE: intentionally NOT calling runAnalysis() on boot.
  // Default coordinates are placeholder values ‚Äî no point burning an API call
  // until the user has set real locations. Calculate button is always available.
});
</script>
</body>
</html>
